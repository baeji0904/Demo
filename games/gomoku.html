<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Omok AI - Smart Version</title>
<style>
  :root{--bg:#0e1220;--ink:#e9edff;--muted:#9aa3c8;--panel:#171a2f;--accent:#7aa2ff;--danger:#ff6b6b}
  *{box-sizing:border-box}
  html,body{margin:0;padding:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,-apple-system,Segoe UI,Roboto;overscroll-behavior:none;}
  .wrap{max-width:800px;margin:0 auto;padding:16px;display:flex;flex-direction:column;min-height:100vh;}
  header{display:flex;justify-content:space-between;gap:12px;align-items:center;flex-wrap:wrap;}
  h1{font-size:20px;margin:0;color:var(--accent);}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin:8px 0;}
  .btn{padding:8px 14px;border:1px solid #2a315e;border-radius:8px;background:#1b2145;color:var(--ink);cursor:pointer;font-weight:600;font-size:13px;transition:all 0.2s;}
  .btn:active{transform:translateY(1px);}
  .btn-primary{background:var(--accent);color:#0e1220;border-color:var(--accent);}
  .tag{display:inline-flex;align-items:center;gap:6px;padding:4px 10px;border:1px solid #2b325c;border-radius:999px;background:#131625;color:var(--muted);font-size:12px}
  .panel{background:var(--panel);border:1px solid #242a49;border-radius:16px;padding:12px;box-shadow:0 8px 24px rgba(0,0,0,.3);position:relative;}
  canvas{display:block;width:100%;height:auto;aspect-ratio:1;border-radius:8px;background:#e0c388;cursor:crosshair;touch-action:none;}
  select{background:#1b2145;color:var(--ink);border:1px solid #2a315e;border-radius:6px;padding:4px 8px;outline:none;}
  .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0}
  
  /* Loading Spinner */
  .spinner{width:16px;height:16px;border:2px solid rgba(255,255,255,0.3);border-radius:50%;border-top-color:#fff;animation:spin 1s ease-in-out infinite;display:none;}
  @keyframes spin{to{transform:rotate(360deg);}}
  .thinking .spinner{display:inline-block;}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>오목 AI</h1>
    <div class="row">
      <button id="btn-undo" class="btn">무르기</button>
      <button id="btn-reset" class="btn btn-primary">새 게임</button>
    </div>
  </header>

  <div class="row">
    <span class="tag">모드
      <select id="modeSel">
        <option value="ai" selected>1인 (vs AI)</option>
        <option value="pvp">2인 (친구)</option>
      </select>
    </span>
    <span class="tag">난이도
      <select id="lvlSel">
        <option value="1">하수</option>
        <option value="2">중수</option>
        <option value="3" selected>고수</option>
      </select>
    </span>
    <span class="tag">내 색깔
      <select id="colorSel">
        <option value="1" selected>흑 (선공)</option>
        <option value="2">백 (후공)</option>
      </select>
    </span>
    <span class="tag">
      <span id="aiStatus">대기</span>
      <div class="spinner"></div>
    </span>
  </div>

  <div class="panel">
    <canvas id="board"></canvas>
    <div id="msg" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.8);color:white;padding:12px 24px;border-radius:20px;pointer-events:none;opacity:0;transition:opacity 0.3s;"></div>
  </div>
  
  <div class="row" style="justify-content:center; margin-top:10px;">
    <span class="tag" style="border-color:transparent; background:transparent;">현재 차례: <strong id="turnDisp" style="color:var(--accent); margin-left:4px;">흑</strong></span>
  </div>
</div>

<script>
(function(){
  'use strict';
  
  // === UI Elements ===
  const cvs = document.getElementById('board');
  const ctx = cvs.getContext('2d');
  const turnDisp = document.getElementById('turnDisp');
  const msgEl = document.getElementById('msg');
  const aiStatEl = document.getElementById('aiStatus');
  const aiSpinner = document.querySelector('.tag'); // Parent of spinner
  
  // === Game State ===
  let N = 15;
  let grid = new Array(N*N).fill(0);
  let toPlay = 1; // 1=Black, 2=White
  let history = [];
  let lastMove = null;
  let gameEnded = false;
  let mode = 'ai';
  let playerColor = 1;
  let level = 3;
  let aiThinking = false;

  // === Constants ===
  const BLACK = 1, WHITE = 2, EMPTY = 0;
  
  // === Web Worker for AI ===
  let aiWorker = null;

  function initWorker() {
    if(aiWorker) aiWorker.terminate();
    
    const workerCode = `
      self.onmessage = function(e) {
        const { grid, size, depth, turn } = e.data;
        const N = size;
        const ME = turn;
        const OPP = 3 - turn;
        
        // --- Heuristic Evaluation Config ---
        // 패턴 점수: [패턴이름, 내점수, 상대방막는점수]
        // Live: 양쪽 열림, Dead: 한쪽 막힘
        const SCORES = {
          WIN5: 100000000,
          LIVE4: 1000000, // .XXXX. -> 무조건 승리
          DEAD4: 5000,    // X.XXX or XXX.X -> 막아야 함
          LIVE3: 4000,    // .XXX. -> 다음 턴에 LIVE4 가능
          DEAD3: 100,
          LIVE2: 50,
          DEAD2: 10
        };

        function idx(x, y) { return y * N + x; }
        function inside(x, y) { return x >= 0 && y >= 0 && x < N && y < N; }

        // 4방향: 가로, 세로, 대각선(\), 대각선(/)
        const DIRS = [[1,0], [0,1], [1,1], [1,-1]];

        // 보드 전체 평가 함수
        function evaluateBoard(g, currentTurn) {
          let score = 0;
          // 간단한 위치 가중치 (중앙 선호)
          const center = N / 2;
          for(let y=0; y<N; y++) {
            for(let x=0; x<N; x++) {
              if(g[idx(x,y)] === ME) {
                score += (10 - Math.abs(x - center) - Math.abs(y - center));
              } else if(g[idx(x,y)] === OPP) {
                score -= (10 - Math.abs(x - center) - Math.abs(y - center));
              }
            }
          }
          
          // 패턴 평가
          score += evaluatePatterns(g, ME) * 1.0;
          score -= evaluatePatterns(g, OPP) * 1.2; // 방어 우선 (상대 점수를 더 높게 평가하여 막도록 유도)
          
          return score;
        }

        function evaluatePatterns(g, color) {
          let total = 0;
          // 가로, 세로, 대각선 스캔
          // (최적화를 위해 전체 스캔 대신 돌이 있는 주변만 보는 것이 좋으나, 
          // 여기서는 코드 복잡도를 줄이기 위해 단순화된 로직 사용)
          
          // 단순화: 연속된 돌의 개수와 열린 끝의 개수를 셉니다.
          // 실제로는 15x15 전체를 4방향으로 훑어야 정확합니다.
          
          let lines = [];
          
          // Helper to check line segments
          function checkLine(start, dir) {
            let count = 0;
            let openEnds = 0;
            let currentSeq = 0;
            let blocked = true; // start prev was blocked?
            
            // 한 줄 스캔
            let x = start.x, y = start.y;
            let arr = [];
            while(inside(x, y)) {
              arr.push(g[idx(x,y)]);
              x += dir[0]; y += dir[1];
            }
            
            // arr 분석
            for(let i=0; i<arr.length; i++) {
              if(arr[i] === color) {
                currentSeq++;
              } else if(arr[i] === 0) {
                if(currentSeq > 0) {
                  // End of sequence
                  if(!blocked) checkSeq(currentSeq, 1); // 1 open end (current)
                  else checkSeq(currentSeq, 1); // was blocked start, open end here? actually we need strictly checking ends
                  // Reset
                  currentSeq = 0;
                }
                blocked = false; 
              } else {
                // Opponent stone
                if(currentSeq > 0) {
                   if(!blocked) checkSeq(currentSeq, 1); // Blocked here, but open start
                   else checkSeq(currentSeq, 0); // Blocked both
                   currentSeq = 0;
                }
                blocked = true;
              }
            }
            // End of line loop
             if(currentSeq > 0) {
                if(!blocked) checkSeq(currentSeq, 1);
             }
          }

          // More precise pattern matcher
          // 이 부분은 속도를 위해 단순화된 휴리스틱을 사용합니다.
          // 4방향에 대해 모든 "5칸 윈도우"를 검사하는 방식이 효율적입니다.
          
          for(let y=0; y<N; y++) {
            for(let x=0; x<N; x++) {
               if(g[idx(x,y)] !== 0) continue; // 빈 칸이 아니면 패스 (사실 이미 놓인 돌 기준으로 점수를 매겨야 함)
               // ... 여기서는 생략하고, Minimax 내에서 승패 판단을 우선시함
            }
          }
          
          // **실제 사용될 평가 로직**:
          // 전체 보드를 스캔하여 연속된 패턴을 찾습니다.
          let score = 0;
          
          // 4방향 루프
          for(let d=0; d<4; d++) {
             const dx = DIRS[d][0], dy = DIRS[d][1];
             // 모든 시작점 (가로/세로/대각에 따라 다름)
             // 간단하게 모든 점(x,y)에서 시작하는 5~6칸 길이의 패턴을 봅니다.
             // 중복 제거를 위해 이미 방문한 라인은 건너뛰어야 하지만, 
             // 여기서는 각 셀마다 오른쪽/아래/대각선 방향으로 뻗어나가는 것만 체크합니다.
             
             for(let y=0; y<N; y++) {
               for(let x=0; x<N; x++) {
                 // 해당 방향으로 5칸이 보드 안에 있는지 확인
                 if(!inside(x + dx*4, y + dy*4)) continue;
                 
                 // 패턴 추출
                 let stones = 0;
                 let opps = 0;
                 for(let k=0; k<5; k++) {
                   const v = g[idx(x + dx*k, y + dy*k)];
                   if(v === color) stones++;
                   else if(v !== 0) opps++;
                 }
                 
                 // 점수 부여
                 if(opps === 0) { // 상대 돌이 없어야 공격 기회
                    if(stones === 5) score += SCORES.WIN5;
                    else if(stones === 4) score += SCORES.LIVE4; // 이게 Live인지 Dead인지는 양끝을 더 봐야 함
                    else if(stones === 3) score += SCORES.LIVE3;
                    else if(stones === 2) score += SCORES.LIVE2;
                 }
               }
             }
          }
          return score;
        }
        
        // --- Minimax with Alpha-Beta ---
        function getCandidates(g) {
          // 돌이 있는 곳 주변 2칸 이내의 빈 곳만 탐색 (가지치기)
          const cands = new Set();
          const hasStone = g.some(v => v !== 0);
          if(!hasStone) return [idx(7,7)]; // 첫 수는 중앙

          for(let i=0; i<N*N; i++) {
            if(g[i] !== 0) {
              const cx = i % N, cy = Math.floor(i / N);
              for(let dy=-2; dy<=2; dy++) {
                for(let dx=-2; dx<=2; dx++) {
                  const nx = cx + dx, ny = cy + dy;
                  if(inside(nx, ny) && g[idx(nx,ny)] === 0) {
                    cands.add(idx(nx,ny));
                  }
                }
              }
            }
          }
          return Array.from(cands);
        }

        // 승리 조건 체크 (가벼운 버전)
        function checkWin(g, color) {
           // 최근 놓은 돌 위주로 체크해야 빠르지만, 여기서는 전체 스캔 (안전성)
           // 실제로는 Minimax 재귀 호출 시 마지막 move를 넘겨서 그 주변만 체크하는 게 정석
           // 여기서는 단순 평가점수가 매우 높으면 승리로 간주
           return evaluatePatterns(g, color) >= SCORES.WIN5;
        }
        
        function checkLocalWin(g, x, y, color) {
           for(const [dx,dy] of DIRS) {
             let count = 1;
             // forward
             let tx = x+dx, ty = y+dy;
             while(inside(tx,ty) && g[idx(tx,ty)] === color) { count++; tx+=dx; ty+=dy; }
             // backward
             tx = x-dx; ty = y-dy;
             while(inside(tx,ty) && g[idx(tx,ty)] === color) { count++; tx-=dx; ty-=dy; }
             
             if(count >= 5) return true;
           }
           return false;
        }

        function minimax(g, depth, alpha, beta, maximizingPlayer) {
          if(depth === 0) return evaluateBoard(g, ME);

          const candidates = getCandidates(g);
          if(candidates.length === 0) return 0;
          
          // 정렬 (Move Ordering): 센터에 가깝거나, 당장 점수가 높은 곳 우선
          // 여기서는 생략하거나 간단히 처리

          if(maximizingPlayer) {
            let maxEval = -Infinity;
            for(const move of candidates) {
               const x = move % N, y = Math.floor(move / N);
               
               // 즉시 승리 체크
               g[move] = ME;
               if(checkLocalWin(g, x, y, ME)) { g[move]=0; return SCORES.WIN5; }
               
               const evalVal = minimax(g, depth - 1, alpha, beta, false);
               g[move] = 0;
               maxEval = Math.max(maxEval, evalVal);
               alpha = Math.max(alpha, evalVal);
               if(beta <= alpha) break;
            }
            return maxEval;
          } else {
            let minEval = Infinity;
            for(const move of candidates) {
               const x = move % N, y = Math.floor(move / N);
               
               // 상대 승리 체크 (무조건 막아야 함)
               g[move] = OPP;
               if(checkLocalWin(g, x, y, OPP)) { g[move]=0; return -SCORES.WIN5; }

               const evalVal = minimax(g, depth - 1, alpha, beta, true);
               g[move] = 0;
               minEval = Math.min(minEval, evalVal);
               beta = Math.min(beta, evalVal);
               if(beta <= alpha) break;
            }
            return minEval;
          }
        }

        // --- Main Logic ---
        // 1. 공격: 4개 연속이 있으면 무조건 둠
        // 2. 방어: 상대가 4개 연속이 있으면 무조건 막음
        // 3. 탐색: Minimax
        
        const candidates = getCandidates(grid);
        let bestMove = candidates[0];
        let bestScore = -Infinity;
        
        // 0. 즉시 승리/패배 방어 우선 (필수)
        for(let move of candidates) {
           const x = move % N, y = Math.floor(move / N);
           
           // 내가 이기는 수?
           grid[move] = ME;
           if(checkLocalWin(grid, x, y, ME)) {
             self.postMessage({move}); return;
           }
           grid[move] = 0;
        }
        
        for(let move of candidates) {
           const x = move % N, y = Math.floor(move / N);
           // 상대가 이기는 수? (막아야 함)
           grid[move] = OPP;
           if(checkLocalWin(grid, x, y, OPP)) {
              self.postMessage({move}); return;
           }
           grid[move] = 0;
        }

        // Minimax Start
        for(let move of candidates) {
           grid[move] = ME;
           // 깊이는 성능에 따라 조절 (여기선 2~4)
           // Level 1: depth 1, Level 3: depth 3
           const score = minimax(grid, depth - 1, -Infinity, Infinity, false);
           grid[move] = 0;
           
           // 약간의 랜덤성 (동점일 때)
           const noise = Math.random() * 10;
           if(score + noise > bestScore) {
             bestScore = score + noise;
             bestMove = move;
           }
        }
        
        self.postMessage({move: bestMove});
      };
    `;
    const blob = new Blob([workerCode], {type: 'application/javascript'});
    aiWorker = new Worker(URL.createObjectURL(blob));
    
    aiWorker.onmessage = (e) => {
      const { move } = e.data;
      if(move !== undefined && move !== null) {
        const x = move % N;
        const y = Math.floor(move / N);
        applyMove(x, y);
      }
      aiThinking = false;
      updateStatus();
    };
  }
  
  // === Game Logic ===
  function idx(x, y) { return y * N + x; }
  function inside(x, y) { return x >= 0 && y >= 0 && x < N && y < N; }
  
  function checkWinLocal(g, x, y, color) {
    const DIRS = [[1,0], [0,1], [1,1], [1,-1]];
    for(const [dx, dy] of DIRS) {
      let count = 1;
      let tx = x+dx, ty = y+dy;
      while(inside(tx,ty) && g[idx(tx,ty)] === color) { count++; tx+=dx; ty+=dy; }
      tx = x-dx; ty = y-dy;
      while(inside(tx,ty) && g[idx(tx,ty)] === color) { count++; tx-=dx; ty-=dy; }
      if(count >= 5) return true;
    }
    return false;
  }

  function applyMove(x, y) {
    if(grid[idx(x,y)] !== 0 || gameEnded) return false;
    
    // Save state
    history.push({grid: [...grid], toPlay, lastMove, gameEnded});
    
    // Set stone
    grid[idx(x,y)] = toPlay;
    lastMove = {x, y};
    drawBoard();
    
    // Check Win
    if(checkWinLocal(grid, x, y, toPlay)) {
      gameEnded = true;
      showMsg((toPlay === BLACK ? '흑(Black)' : '백(White)') + ' 승리!');
      updateStatus();
      return true;
    }
    
    // Check Full
    if(!grid.includes(0)) {
      gameEnded = true;
      showMsg('무승부!');
      return true;
    }
    
    // Toggle Turn
    toPlay = 3 - toPlay;
    updateStatus();
    
    // Trigger AI if needed
    if(mode === 'ai' && !gameEnded && toPlay !== playerColor) {
      requestAI();
    }
    return true;
  }
  
  function requestAI() {
    aiThinking = true;
    updateStatus();
    // 난이도에 따른 깊이 설정
    const depth = (level === 1) ? 2 : (level === 2) ? 3 : 4;
    aiWorker.postMessage({ grid, size: N, depth, turn: toPlay });
  }

  function undo() {
    if(aiThinking || history.length === 0) return;
    // AI 모드일 경우 내 차례가 올 때까지(2번) 무르기
    if(mode === 'ai') {
      if(history.length >= 2) {
        history.pop(); // AI move
        const prev = history.pop(); // My move
        restoreState(prev);
      } else {
        // 첫수만 두고 무를 때
        const prev = history.pop();
        restoreState(prev);
      }
    } else {
      const prev = history.pop();
      restoreState(prev);
    }
    gameEnded = false;
    msgEl.style.opacity = 0;
    drawBoard();
    updateStatus();
  }

  function restoreState(state) {
    grid = state.grid;
    toPlay = state.toPlay;
    lastMove = state.lastMove;
    gameEnded = state.gameEnded;
  }
  
  function reset() {
    // Stop AI
    if(aiWorker) initWorker();
    
    grid.fill(0);
    toPlay = 1;
    history = [];
    lastMove = null;
    gameEnded = false;
    aiThinking = false;
    msgEl.style.opacity = 0;
    
    drawBoard();
    updateStatus();
    
    if(mode === 'ai' && playerColor === 2) {
      requestAI();
    }
  }

  // === Drawing ===
  function drawBoard() {
    const W = cvs.width;
    const H = cvs.height;
    
    // Background
    ctx.fillStyle = '#e0c388';
    ctx.fillRect(0, 0, W, H);
    
    const PAD = 30;
    const CELL = (W - PAD * 2) / (N - 1);
    
    // Lines
    ctx.beginPath();
    ctx.lineWidth = 1;
    ctx.strokeStyle = '#000';
    for(let i=0; i<N; i++) {
      const p = PAD + i * CELL;
      ctx.moveTo(PAD, p); ctx.lineTo(W-PAD, p);
      ctx.moveTo(p, PAD); ctx.lineTo(p, H-PAD);
    }
    ctx.stroke();
    
    // Stars (화점)
    const stars = (N===19) ? [3,9,15] : [3,7,11];
    ctx.fillStyle = '#000';
    for(let x of stars) for(let y of stars) {
       ctx.beginPath();
       ctx.arc(PAD + x*CELL, PAD + y*CELL, 3, 0, Math.PI*2);
       ctx.fill();
    }
    
    // Stones
    for(let y=0; y<N; y++) {
      for(let x=0; x<N; x++) {
        const v = grid[idx(x,y)];
        if(v === 0) continue;
        
        const cx = PAD + x*CELL;
        const cy = PAD + y*CELL;
        const r = CELL * 0.45;
        
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI*2);
        
        // Gradient
        const grad = ctx.createRadialGradient(cx-r*0.3, cy-r*0.3, r*0.1, cx, cy, r);
        if(v === BLACK) {
          grad.addColorStop(0, '#555');
          grad.addColorStop(1, '#000');
          ctx.shadowBlur = 4; ctx.shadowColor = 'rgba(0,0,0,0.5)';
        } else {
          grad.addColorStop(0, '#fff');
          grad.addColorStop(1, '#ddd');
          ctx.shadowBlur = 4; ctx.shadowColor = 'rgba(0,0,0,0.3)';
        }
        ctx.fillStyle = grad;
        ctx.fill();
        ctx.shadowBlur = 0;
        
        // Last Move Marker
        if(lastMove && lastMove.x === x && lastMove.y === y) {
          ctx.strokeStyle = '#ef4444';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(cx, cy, r*0.5, 0, Math.PI*2);
          ctx.stroke();
        }
      }
    }
  }
  
  function updateStatus() {
    if(gameEnded) {
      aiStatEl.textContent = "종료";
      aiSpinner.classList.remove('thinking');
      return;
    }
    turnDisp.textContent = (toPlay === BLACK ? '흑' : '백');
    turnDisp.style.color = (toPlay === BLACK ? '#333' : '#fff'); // UI 배경이 어두우므로
    if(document.body.style.backgroundColor !== 'white') {
       turnDisp.style.color = 'var(--accent)';
    }

    if(aiThinking) {
      aiStatEl.textContent = "생각 중...";
      aiSpinner.classList.add('thinking');
    } else {
      aiStatEl.textContent = "대기";
      aiSpinner.classList.remove('thinking');
    }
  }

  function showMsg(text) {
    msgEl.textContent = text;
    msgEl.style.opacity = 1;
    setTimeout(() => { msgEl.style.opacity = 0; }, 2000);
  }

  function resize() {
    const size = Math.min(window.innerWidth - 32, 600);
    cvs.width = size;
    cvs.height = size;
    drawBoard();
  }
  
  // === Inputs ===
  function getXY(e) {
    const rect = cvs.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const W = cvs.width;
    const PAD = 30; // Scale 맞춰야 함
    // Canvas 크기가 CSS 크기와 다를 수 있음
    const scaleX = cvs.width / rect.width;
    const scaleY = cvs.height / rect.height;
    
    const rx = x * scaleX;
    const ry = y * scaleY;
    
    const CELL = (W - PAD*2) / (N-1);
    
    const bx = Math.round((rx - PAD) / CELL);
    const by = Math.round((ry - PAD) / CELL);
    return {x: bx, y: by};
  }
  
  function handleClick(e) {
    if(aiThinking || gameEnded) return;
    const {x, y} = getXY(e);
    if(inside(x,y)) {
      if(mode === 'ai' && toPlay !== playerColor) return;
      applyMove(x, y);
    }
  }

  // === Init ===
  window.addEventListener('resize', resize);
  cvs.addEventListener('click', handleClick); // PC
  
  // UI Bindings
  document.getElementById('btn-reset').onclick = reset;
  document.getElementById('btn-undo').onclick = undo;
  
  const modeSel = document.getElementById('modeSel');
  const lvlSel = document.getElementById('lvlSel');
  const colorSel = document.getElementById('colorSel');
  
  modeSel.onchange = () => { mode = modeSel.value; reset(); };
  lvlSel.onchange = () => { level = parseInt(lvlSel.value); reset(); };
  colorSel.onchange = () => { playerColor = parseInt(colorSel.value); reset(); };

  initWorker();
  resize();
  reset();

})();
</script>
</body>
</html>
