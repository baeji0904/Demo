<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Omok AI - Fast & Smart</title>
<style>
  :root{--bg:#0e1220;--ink:#e9edff;--muted:#9aa3c8;--panel:#171a2f;--accent:#7aa2ff;--danger:#ff6b6b}
  *{box-sizing:border-box}
  html,body{margin:0;padding:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,-apple-system,Segoe UI,Roboto;overscroll-behavior:none;}
  .wrap{max-width:800px;margin:0 auto;padding:16px;display:flex;flex-direction:column;min-height:100vh;}
  header{display:flex;justify-content:space-between;gap:12px;align-items:center;flex-wrap:wrap;}
  h1{font-size:20px;margin:0;color:var(--accent);}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin:8px 0;}
  .btn{padding:8px 14px;border:1px solid #2a315e;border-radius:8px;background:#1b2145;color:var(--ink);cursor:pointer;font-weight:600;font-size:13px;transition:all 0.2s;}
  .btn:active{transform:translateY(1px);}
  .btn-primary{background:var(--accent);color:#0e1220;border-color:var(--accent);}
  .tag{display:inline-flex;align-items:center;gap:6px;padding:4px 10px;border:1px solid #2b325c;border-radius:999px;background:#131625;color:var(--muted);font-size:12px}
  .panel{background:var(--panel);border:1px solid #242a49;border-radius:16px;padding:12px;box-shadow:0 8px 24px rgba(0,0,0,.3);position:relative;}
  canvas{display:block;width:100%;height:auto;aspect-ratio:1;border-radius:8px;background:#e0c388;cursor:crosshair;touch-action:none;}
  select{background:#1b2145;color:var(--ink);border:1px solid #2a315e;border-radius:6px;padding:4px 8px;outline:none;}
  .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0}
  
  /* Loading Spinner */
  .spinner{width:16px;height:16px;border:2px solid rgba(255,255,255,0.3);border-radius:50%;border-top-color:#fff;animation:spin 1s ease-in-out infinite;display:none;}
  @keyframes spin{to{transform:rotate(360deg);}}
  .thinking .spinner{display:inline-block;}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>오목 AI (고속)</h1>
    <div class="row">
      <button id="btn-undo" class="btn">무르기</button>
      <button id="btn-reset" class="btn btn-primary">새 게임</button>
    </div>
  </header>

  <div class="row">
    <span class="tag">모드
      <select id="modeSel">
        <option value="ai" selected>1인 (vs AI)</option>
        <option value="pvp">2인 (친구)</option>
      </select>
    </span>
    <span class="tag">난이도
      <select id="lvlSel">
        <option value="1">초급</option>
        <option value="2" selected>중급</option>
        <option value="3">고급</option>
      </select>
    </span>
    <span class="tag">내 색깔
      <select id="colorSel">
        <option value="1" selected>흑 (선공)</option>
        <option value="2">백 (후공)</option>
      </select>
    </span>
    <span class="tag">
      <span id="aiStatus">대기</span>
      <div class="spinner"></div>
    </span>
  </div>

  <div class="panel">
    <canvas id="board"></canvas>
    <div id="msg" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.8);color:white;padding:12px 24px;border-radius:20px;pointer-events:none;opacity:0;transition:opacity 0.3s;"></div>
  </div>
  
  <div class="row" style="justify-content:center; margin-top:10px;">
    <span class="tag" style="border-color:transparent; background:transparent;">현재 차례: <strong id="turnDisp" style="color:var(--accent); margin-left:4px;">흑</strong></span>
  </div>
</div>

<script>
(function(){
  'use strict';
  
  // === UI Elements ===
  const cvs = document.getElementById('board');
  const ctx = cvs.getContext('2d');
  const turnDisp = document.getElementById('turnDisp');
  const msgEl = document.getElementById('msg');
  const aiStatEl = document.getElementById('aiStatus');
  const aiSpinner = document.querySelector('.tag'); 
  
  // === Game State ===
  let N = 15;
  let grid = new Array(N*N).fill(0);
  let toPlay = 1; // 1=Black, 2=White
  let history = [];
  let lastMove = null;
  let gameEnded = false;
  let mode = 'ai';
  let playerColor = 1;
  let level = 2; // Default Medium
  let aiThinking = false;

  // === Constants ===
  const BLACK = 1, WHITE = 2, EMPTY = 0;
  
  // === Web Worker for AI ===
  let aiWorker = null;

  function initWorker() {
    if(aiWorker) aiWorker.terminate();
    
    // AI Worker Code
    const workerCode = `
      self.onmessage = function(e) {
        const { grid, size, level, turn } = e.data;
        const N = size;
        const ME = turn;
        const OPP = 3 - turn;
        const TIME_LIMIT = 900; // 0.9초 제한 (매우 빠름)

        // 방향: 가로, 세로, 대각선, 역대각선
        const DIRS = [[1,0], [0,1], [1,1], [1,-1]];
        
        function idx(x, y) { return y * N + x; }
        function inside(x, y) { return x >= 0 && y >= 0 && x < N && y < N; }

        // --- 1. 후보군 선정 (매우 중요: 전체 탐색 방지) ---
        function getSmartCandidates(g) {
          const candidates = new Map();
          const hasStone = g.some(v => v !== 0);
          if(!hasStone) return [idx(7,7)]; // 첫 수는 중앙

          // 돌이 있는 곳 주변 1~2칸 범위만 탐색
          for(let i=0; i<N*N; i++) {
            if(g[i] !== 0) {
              const cx = i % N, cy = Math.floor(i / N);
              // 범위: 주변 2칸
              for(let dy=-2; dy<=2; dy++) {
                for(let dx=-2; dx<=2; dx++) {
                  if(dx===0 && dy===0) continue;
                  const nx = cx + dx, ny = cy + dy;
                  if(inside(nx, ny) && g[idx(nx,ny)] === 0) {
                    const p = idx(nx,ny);
                    // 중앙에 가까울수록 미세한 가산점 (1~2점)
                    let score = (10 - Math.abs(nx - 7) - Math.abs(ny - 7)); 
                    // 이미 후보에 있으면 기존 점수 유지
                    if(!candidates.has(p)) candidates.set(p, score);
                  }
                }
              }
            }
          }
          
          // 후보군을 점수순 정렬하되, '휴리스틱'으로 더 좋은 후보를 앞으로 보냄
          // 여기서는 간단하게 "주변에 돌이 많은 곳"을 우선순위로 둠
          const sorted = Array.from(candidates.keys());
          
          // 간단한 정렬: 인접한 돌 개수가 많은 순서 (공격/방어 요충지일 확률 높음)
          sorted.sort((a,b) => {
             return countNeighbors(g, b) - countNeighbors(g, a);
          });

          // 상위 20개만 리턴 (가지치기 핵심)
          return sorted.slice(0, 20); 
        }

        function countNeighbors(g, p) {
           const cx = p % N, cy = Math.floor(p / N);
           let cnt = 0;
           for(let dy=-1; dy<=1; dy++) {
             for(let dx=-1; dx<=1; dx++) {
               if(dx===0 && dy===0) continue;
               const nx=cx+dx, ny=cy+dy;
               if(inside(nx,ny) && g[idx(nx,ny)] !== 0) cnt++;
             }
           }
           return cnt;
        }

        // --- 2. 평가 함수 (Heuristic) ---
        function evaluateLine(count, openEnds, currentTurn) {
           if(count >= 5) return 10000000;
           if(count === 4) {
              if(openEnds === 2) return 1000000; // Live 4 (무적)
              if(openEnds === 1) return 50000;   // Dead 4 (막아야 함)
           }
           if(count === 3) {
              if(openEnds === 2) return 50000;   // Live 3 (위험)
              if(openEnds === 1) return 1000;
           }
           if(count === 2) {
              if(openEnds === 2) return 500;
              return 100;
           }
           return 0;
        }

        function evaluateBoard(g) {
           let totalScore = 0;
           
           // 전체 스캔 대신 주요 라인만 스캔하면 빠르지만, 
           // 여기서는 단순화를 위해 전체 스캔하되 로직을 경량화
           // (실전에서는 4방향 전체 스캔이 무겁습니다. 약식 구현)
           
           // 성능을 위해: 가로/세로/대각선을 일일이 다 돌지 않고,
           // "패턴 점수"를 미리 정의하지 않고 실시간 계산
           
           let myScore = 0;
           let oppScore = 0;

           // 가로/세로/대각선 한번에 처리
           // (worker 내부라 loop가 좀 많아도 됨, 단 뎁스가 깊어지면 문제)
           // 여기서는 Minimax의 말단 노드에서만 호출됨
           
           // *** 최적화된 평가: 전체를 훑지 않고 돌이 있는 라인만 체크 ***
           // (구현 복잡도 때문에 여기서는 기존 방식 유지하되 가중치만 조절)
           
           // 간단 평가: 
           // 연속된 돌의 개수 + 열린 끝의 개수
           
           for(let y=0; y<N; y++) {
             for(let x=0; x<N; x++) {
               if(g[idx(x,y)] === 0) continue;
               const c = g[idx(x,y)];
               
               for(let d=0; d<4; d++) {
                 const dx = DIRS[d][0], dy = DIRS[d][1];
                 // 이미 검사한 방향 패스 (역방향 체크 안함, 시작점만 체크)
                 const px = x-dx, py = y-dy;
                 if(inside(px,py) && g[idx(px,py)] === c) continue; 
                 
                 let count = 0;
                 let tx = x, ty = y;
                 while(inside(tx,ty) && g[idx(tx,ty)] === c) {
                   count++; tx+=dx; ty+=dy;
                 }
                 
                 // 양쪽 끝 열림 확인
                 let open = 0;
                 if(inside(tx,ty) && g[idx(tx,ty)] === 0) open++;
                 if(inside(x-dx, y-dy) && g[idx(x-dx,y-dy)] === 0) open++;
                 
                 const sc = evaluateLine(count, open);
                 if(c === ME) myScore += sc;
                 else oppScore += sc;
               }
             }
           }
           return myScore - (oppScore * 1.2); // 방어 중시
        }

        // --- 3. 승리 체크 (빠른 버전) ---
        function checkWin(g, move, color) {
           const cx = move % N, cy = Math.floor(move / N);
           for(const [dx,dy] of DIRS) {
             let cnt = 1;
             let tx = cx+dx, ty = cy+dy;
             while(inside(tx,ty) && g[idx(tx,ty)] === color) { cnt++; tx+=dx; ty+=dy; }
             tx = cx-dx; ty = cy-dy;
             while(inside(tx,ty) && g[idx(tx,ty)] === color) { cnt++; tx-=dx; ty-=dy; }
             if(cnt >= 5) return true;
           }
           return false;
        }

        // --- 4. Alpha-Beta Pruning with Time Limit ---
        let startTime = 0;
        let timeout = false;

        function minimax(g, depth, alpha, beta, isMax) {
          if(timeout) return 0;
          if((Date.now() - startTime) > TIME_LIMIT) { timeout = true; return 0; }

          if(depth === 0) return evaluateBoard(g);

          const candidates = getSmartCandidates(g);
          if(candidates.length === 0) return 0;

          if(isMax) {
            let maxEval = -Infinity;
            for(const move of candidates) {
              // 즉시 승리 체크
              g[move] = ME;
              if(checkWin(g, move, ME)) { g[move]=0; return 100000000; } // Win logic
              
              const val = minimax(g, depth-1, alpha, beta, false);
              g[move] = 0;
              if(timeout) return val;

              maxEval = Math.max(maxEval, val);
              alpha = Math.max(alpha, val);
              if(beta <= alpha) break;
            }
            return maxEval;
          } else {
            let minEval = Infinity;
            for(const move of candidates) {
              g[move] = OPP;
              if(checkWin(g, move, OPP)) { g[move]=0; return -100000000; } // Block logic

              const val = minimax(g, depth-1, alpha, beta, true);
              g[move] = 0;
              if(timeout) return val;

              minEval = Math.min(minEval, val);
              beta = Math.min(beta, val);
              if(beta <= alpha) break;
            }
            return minEval;
          }
        }

        // --- Main Execution ---
        
        // 1. 긴급 방어/공격 (4목 등) - Minimax 돌릴 필요도 없음
        const urgentCands = getSmartCandidates(grid); // 상위 후보들만
        for(let m of urgentCands) {
           grid[m] = ME;
           if(checkWin(grid, m, ME)) { self.postMessage({move:m}); return; }
           grid[m] = 0;
        }
        for(let m of urgentCands) {
           grid[m] = OPP;
           if(checkWin(grid, m, OPP)) { self.postMessage({move:m}); return; } // 필사적 방어
           grid[m] = 0;
        }

        // 2. Iterative Deepening (시간 남으면 더 깊게)
        startTime = Date.now();
        timeout = false;
        
        let bestMove = urgentCands[0];
        // 난이도별 최대 깊이: 하수=2, 중수=3, 고수=4 (고수도 시간제한 걸림)
        const maxDepth = (level === 1) ? 2 : (level === 2) ? 3 : 5; 
        
        // Depth 2부터 시작해서 시간 되는대로 깊게
        for(let d=2; d<=maxDepth; d++) {
           let currentBestMove = null;
           let maxScore = -Infinity;
           
           // Root Level Search
           for(let move of urgentCands) {
             grid[move] = ME;
             const score = minimax(grid, d-1, -Infinity, Infinity, false);
             grid[move] = 0;
             
             if(timeout) break; // 시간 초과시 루프 탈출

             // 약간의 랜덤성 (너무 기계적이지 않게)
             const noise = Math.random() * 5; 
             if(score + noise > maxScore) {
               maxScore = score + noise;
               currentBestMove = move;
             }
           }
           
           if(!timeout && currentBestMove !== null) {
              bestMove = currentBestMove; // 시간 내에 완료했으면 갱신
           } else {
              break; // 시간 초과면 이전 깊이의 bestMove 사용
           }
        }
        
        self.postMessage({move: bestMove});
      };
    `;
    const blob = new Blob([workerCode], {type: 'application/javascript'});
    aiWorker = new Worker(URL.createObjectURL(blob));
    
    aiWorker.onmessage = (e) => {
      const { move } = e.data;
      if(move !== undefined && move !== null) {
        const x = move % N;
        const y = Math.floor(move / N);
        applyMove(x, y);
      }
      aiThinking = false;
      updateStatus();
    };
  }
  
  // === Game Logic ===
  function idx(x, y) { return y * N + x; }
  function inside(x, y) { return x >= 0 && y >= 0 && x < N && y < N; }
  
  function checkWinLocal(g, x, y, color) {
    const DIRS = [[1,0], [0,1], [1,1], [1,-1]];
    for(const [dx, dy] of DIRS) {
      let count = 1;
      let tx = x+dx, ty = y+dy;
      while(inside(tx,ty) && g[idx(tx,ty)] === color) { count++; tx+=dx; ty+=dy; }
      tx = x-dx; ty = y-dy;
      while(inside(tx,ty) && g[idx(tx,ty)] === color) { count++; tx-=dx; ty-=dy; }
      if(count >= 5) return true;
    }
    return false;
  }

  function applyMove(x, y) {
    if(grid[idx(x,y)] !== 0 || gameEnded) return false;
    
    // Save state
    history.push({grid: [...grid], toPlay, lastMove, gameEnded});
    
    // Set stone
    grid[idx(x,y)] = toPlay;
    lastMove = {x, y};
    drawBoard();
    
    // Check Win
    if(checkWinLocal(grid, x, y, toPlay)) {
      gameEnded = true;
      showMsg((toPlay === BLACK ? '흑(Black)' : '백(White)') + ' 승리!');
      updateStatus();
      return true;
    }
    
    // Check Full
    if(!grid.includes(0)) {
      gameEnded = true;
      showMsg('무승부!');
      return true;
    }
    
    // Toggle Turn
    toPlay = 3 - toPlay;
    updateStatus();
    
    // Trigger AI if needed
    if(mode === 'ai' && !gameEnded && toPlay !== playerColor) {
      requestAI();
    }
    return true;
  }
  
  function requestAI() {
    aiThinking = true;
    updateStatus();
    // Worker에 작업 요청 (레벨 전달)
    aiWorker.postMessage({ grid, size: N, level, turn: toPlay });
  }

  function undo() {
    if(aiThinking || history.length === 0) return;
    if(mode === 'ai') {
      if(history.length >= 2) {
        history.pop(); 
        const prev = history.pop();
        restoreState(prev);
      } else {
        const prev = history.pop();
        restoreState(prev);
      }
    } else {
      const prev = history.pop();
      restoreState(prev);
    }
    gameEnded = false;
    msgEl.style.opacity = 0;
    drawBoard();
    updateStatus();
  }

  function restoreState(state) {
    grid = state.grid;
    toPlay = state.toPlay;
    lastMove = state.lastMove;
    gameEnded = state.gameEnded;
  }
  
  function reset() {
    if(aiWorker) initWorker();
    
    grid.fill(0);
    toPlay = 1;
    history = [];
    lastMove = null;
    gameEnded = false;
    aiThinking = false;
    msgEl.style.opacity = 0;
    
    drawBoard();
    updateStatus();
    
    if(mode === 'ai' && playerColor === 2) {
      requestAI();
    }
  }

  // === Drawing ===
  function drawBoard() {
    const W = cvs.width;
    const H = cvs.height;
    
    ctx.fillStyle = '#e0c388';
    ctx.fillRect(0, 0, W, H);
    
    const PAD = 30;
    const CELL = (W - PAD * 2) / (N - 1);
    
    ctx.beginPath();
    ctx.lineWidth = 1;
    ctx.strokeStyle = '#000';
    for(let i=0; i<N; i++) {
      const p = PAD + i * CELL;
      ctx.moveTo(PAD, p); ctx.lineTo(W-PAD, p);
      ctx.moveTo(p, PAD); ctx.lineTo(p, H-PAD);
    }
    ctx.stroke();
    
    const stars = (N===19) ? [3,9,15] : [3,7,11];
    ctx.fillStyle = '#000';
    for(let x of stars) for(let y of stars) {
       ctx.beginPath();
       ctx.arc(PAD + x*CELL, PAD + y*CELL, 3, 0, Math.PI*2);
       ctx.fill();
    }
    
    for(let y=0; y<N; y++) {
      for(let x=0; x<N; x++) {
        const v = grid[idx(x,y)];
        if(v === 0) continue;
        
        const cx = PAD + x*CELL;
        const cy = PAD + y*CELL;
        const r = CELL * 0.45;
        
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI*2);
        
        const grad = ctx.createRadialGradient(cx-r*0.3, cy-r*0.3, r*0.1, cx, cy, r);
        if(v === BLACK) {
          grad.addColorStop(0, '#555');
          grad.addColorStop(1, '#000');
          ctx.shadowBlur = 4; ctx.shadowColor = 'rgba(0,0,0,0.5)';
        } else {
          grad.addColorStop(0, '#fff');
          grad.addColorStop(1, '#ddd');
          ctx.shadowBlur = 4; ctx.shadowColor = 'rgba(0,0,0,0.3)';
        }
        ctx.fillStyle = grad;
        ctx.fill();
        ctx.shadowBlur = 0;
        
        if(lastMove && lastMove.x === x && lastMove.y === y) {
          ctx.strokeStyle = '#ef4444';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(cx, cy, r*0.5, 0, Math.PI*2);
          ctx.stroke();
        }
      }
    }
  }
  
  function updateStatus() {
    if(gameEnded) {
      aiStatEl.textContent = "종료";
      aiSpinner.classList.remove('thinking');
      return;
    }
    turnDisp.textContent = (toPlay === BLACK ? '흑' : '백');
    turnDisp.style.color = (toPlay === BLACK ? '#333' : '#fff');
    if(document.body.style.backgroundColor !== 'white') {
       turnDisp.style.color = 'var(--accent)';
    }

    if(aiThinking) {
      aiStatEl.textContent = "생각 중...";
      aiSpinner.classList.add('thinking');
    } else {
      aiStatEl.textContent = "대기";
      aiSpinner.classList.remove('thinking');
    }
  }

  function showMsg(text) {
    msgEl.textContent = text;
    msgEl.style.opacity = 1;
    setTimeout(() => { msgEl.style.opacity = 0; }, 2000);
  }

  function resize() {
    const size = Math.min(window.innerWidth - 32, 600);
    cvs.width = size;
    cvs.height = size;
    drawBoard();
  }
  
  // === Inputs ===
  function getXY(e) {
    const rect = cvs.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const W = cvs.width;
    const PAD = 30; 
    const scaleX = cvs.width / rect.width;
    const scaleY = cvs.height / rect.height;
    
    const rx = x * scaleX;
    const ry = y * scaleY;
    
    const CELL = (W - PAD*2) / (N-1);
    
    const bx = Math.round((rx - PAD) / CELL);
    const by = Math.round((ry - PAD) / CELL);
    return {x: bx, y: by};
  }
  
  function handleClick(e) {
    if(aiThinking || gameEnded) return;
    const {x, y} = getXY(e);
    if(inside(x,y)) {
      if(mode === 'ai' && toPlay !== playerColor) return;
      applyMove(x, y);
    }
  }

  // === Init ===
  window.addEventListener('resize', resize);
  cvs.addEventListener('click', handleClick); 
  
  document.getElementById('btn-reset').onclick = reset;
  document.getElementById('btn-undo').onclick = undo;
  
  const modeSel = document.getElementById('modeSel');
  const lvlSel = document.getElementById('lvlSel');
  const colorSel = document.getElementById('colorSel');
  
  modeSel.onchange = () => { mode = modeSel.value; reset(); };
  lvlSel.onchange = () => { level = parseInt(lvlSel.value); reset(); };
  colorSel.onchange = () => { playerColor = parseInt(colorSel.value); reset(); };

  initWorker();
  resize();
  reset();

})();
</script>
</body>
</html>
