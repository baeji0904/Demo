<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Galaga-like â€“ ì—…ê·¸ë ˆì´ë“œ + ì§€ì›ê¸° + ê¶ê·¹ê¸°</title>
<style>
  :root{
    --bg:#070a16; --panel:#11152b; --ink:#e9edff; --muted:#9aa3c7; --accent:#7aa2ff;
    --panel2:#0b0f1e;
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto}
  .wrap{max-width:980px;margin:0 auto;padding:16px}
  header{display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap}
  h1{font-size:22px;margin:0}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .btn{padding:8px 12px;border:1px solid #2a315e;border-radius:12px;background:#1b2145;color:var(--ink);cursor:pointer}
  .btn:disabled{opacity:.55;cursor:not-allowed}
  .btn-primary{background:linear-gradient(180deg,#2e4cff,#2337a7);border-color:#3a50ff}
  .tag{display:inline-flex;gap:8px;align-items:center;padding:6px 10px;border:1px solid #2b325c;border-radius:999px;background:#121632;color:var(--muted)}
  .panel{background:var(--panel2);border:1px solid #222747;border-radius:16px;padding:12px}
  canvas{width:100%;height:auto;border-radius:12px;display:block;background:radial-gradient(1000px 500px at 50% -200px,#0d1440 10%,#060a1a 60%,#02040a 100%)}
  .pad{display:flex;gap:10px;justify-content:center;margin-top:8px;flex-wrap:wrap}
  .pad .btn{min-width:90px}
  .hud{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin:8px 0}
  .download-link{
    display:inline-block;margin-top:10px;padding:7px 13px;border-radius:999px;
    background:#22c55e;color:#022c22;font-weight:600;text-decoration:none;
    border:1px solid #15803d;
  }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>ê°¤ëŸ¬ê·¸ (Galaga-like)</h1>
    <div class="row">
      <button id="btn-start" class="btn btn-primary">ì‹œì‘ / ì¬ì‹œì‘</button>
      <button id="btn-pause" class="btn">ì¼ì‹œì •ì§€</button>
      <button id="btn-mute" class="btn" aria-pressed="false">ğŸ”Š ìŒì†Œê±°</button>
    </div>
  </header>
  <div class="hud">
    <span class="tag">ì ìˆ˜ <b id="score">0</b></span>
    <span class="tag">ì›¨ì´ë¸Œ <b id="wave">1</b></span>
    <span class="tag">ë¼ì´í”„ <b id="lives">3</b></span>
    <span class="tag">ê¶ê·¹ê¸° <b id="ult">0</b></span>
    <span class="tag">ìµœê³  <b id="best">0</b></span>
  </div>
  <div class="panel">
    <canvas id="game" width="800" height="600" aria-label="Galaga-like"></canvas>
    <div class="pad">
      <button id="left" class="btn">â—€ ì™¼ìª½</button>
      <button id="fire" class="btn btn-primary">ë°œì‚¬</button>
      <button id="right" class="btn">ì˜¤ë¥¸ìª½ â–¶</button>
    </div>
    <div style="color:#9aa3c7;font-size:14px;margin-top:6px">
      â† â†’ ì´ë™, <b>Space</b> ë°œì‚¬, <b>P</b> ì¼ì‹œì •ì§€, <b>B</b> ê¶ê·¹ê¸°. í„°ì¹˜/ë²„íŠ¼ ì§€ì›.
    </div>
    <a href="galaga_wave_fx.html" download="galaga_wave_fx.html" class="download-link">
      ì´ ì½”ë“œ ë‹¤ìš´ë¡œë“œ
    </a>
  </div>
</div>
<script>
(function(){
  'use strict';
  // ===== Canvas & DPR =====
  const CV = document.getElementById('game');
  const CTX = CV.getContext('2d');
  let DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1));
  function fit(){
    const w = CV.clientWidth;
    const ratio = w/800;
    CV.style.height = (600*ratio)+'px';
    CV.width = Math.floor(800*DPR);
    CV.height = Math.floor(600*DPR);
    CTX.setTransform(DPR,0,0,DPR,0,0);
  }
  window.addEventListener('resize', fit);

  // ===== UI =====
  const $ = id=>document.getElementById(id);
  const hud = {
    score:$('score'),
    wave:$('wave'),
    lives:$('lives'),
    best:$('best'),
    ult:$('ult')
  };
  const btnStart=$('btn-start'), btnPause=$('btn-pause'), btnMute=$('btn-mute');
  const btLeft=$('left'), btRight=$('right'), btFire=$('fire');

  // ===== Audio (beeps) =====
  const SND = (()=>{
    const AC = (window.AudioContext||window.webkitAudioContext)
      ? new (window.AudioContext||window.webkitAudioContext)()
      : null;
    let muted=false;
    function blip(freq,dur=0.06,g=0.06,type='square'){
      if(!AC || muted) return;
      const t0 = AC.currentTime,
            o=AC.createOscillator(),
            gn=AC.createGain();
      o.type=type; o.frequency.value=freq;
      gn.gain.setValueAtTime(0, t0);
      gn.gain.linearRampToValueAtTime(g, t0+0.005);
      gn.gain.exponentialRampToValueAtTime(0.0001, t0+dur);
      o.connect(gn).connect(AC.destination);
      o.start(t0); o.stop(t0+dur+0.02);
    }
    return {
      setMuted(v){ muted=v; },
      shoot(){ blip(740,0.06,0.08,'square'); },
      hit(){ blip(220,0.1,0.1,'sawtooth'); },
      die(){
        blip(260,0.08,0.12,'square');
        blip(90,0.3,0.2,'sawtooth');
      },
      wave(){ blip(520,0.18,0.08,'triangle'); },
    };
  })();

  // ===== Game State =====
  const SAVE_KEY='galaga.best.v1';
  let bestInit = 0;
  try {
    bestInit = Number(localStorage.getItem(SAVE_KEY) || 0);
    if(!Number.isFinite(bestInit)) bestInit = 0;
  } catch(e){
    bestInit = 0;
  }

  const G = {
    w:800, h:600,
    player:{x:400,y:560,w:26,h:20,speed:440,cool:0.18},
    bullet:{speed:600,r:3},
    enemyBullet:{speed:240,r:4},
    starCount:120
  };
  const C = {
    star:'#1d2244', star2:'#2b3a8a', ink:'#e9edff',
    player:'#8ef6d0', bullet:'#ffd685', enemy:'#7aa2ff',
    enemy2:'#ff9aa2', enemy3:'#ffd685', enemyShot:'#ff6e7a',
    glow:'#050712', overlay:'rgba(0,0,0,.35)',
    supportItem:'#22c55e'
  };

  let S = {
    running:false, paused:false, over:false,
    score:0, best:bestInit,
    wave:1, lives:3,
    keys:new Set(),
    leftHold:false, rightHold:false, fireHold:false,
    ultCharges:0          // ê¶ê·¹ê¸° ê°œìˆ˜
  };

  // Entities
  let player=null, bullets=[], enemyBullets=[], enemies=[], explosions=[], stars=[];
  let scorePops = [];   // í° ì ìˆ˜ íŒì—…ë“¤
  let waveBanner = null; // ì›¨ì´ë¸Œ ì‹œì‘ í…ìŠ¤íŠ¸

  // ìƒˆë¡œ ì¶”ê°€: ì§€ì›ê¸°/ì•„ì´í…œ ìƒíƒœ
  let helper = null;              // í”Œë ˆì´ì–´ ì˜¤ë¥¸ìª½ì— ë¶™ëŠ” ì§€ì›ê¸°
  let supportItem = null;         // í™”ë©´ì— ë–  ìˆëŠ” ì•„ì´í…œ
  let waveTime = 0;               // ì›¨ì´ë¸Œ ê²½ê³¼ ì‹œê°„
  let itemSpawnedThisWave = false;// í•œ ì›¨ì´ë¸Œì— ì•„ì´í…œ 1ë²ˆë§Œ

  // ë³´ìŠ¤ ìƒíƒœ
  let boss = null;
  let bossBullets = [];
  let bossShotTimer = 0;
  let bossBigTimer = 0;
  let invulTime = 0;      // í”Œë ˆì´ì–´ í”¼ê²© í›„ ë¬´ì  ì‹œê°„(ì´ˆ)

  // ê¶ê·¹ê¸° ì—°ì¶œ ìƒíƒœ
  let ultFlash = null;    // {t, dur}
  let shakeTime = 0;      // ë‚¨ì€ í”ë“¤ë¦¼ ì‹œê°„

  function resetPlayer(){
    player = {
      x:G.w/2,
      y:G.player.y,
      w:G.player.w,
      h:G.player.h,
      vx:0,
      cool:0,
      powerLevel:1   // 1 = ê¸°ë³¸, 2 = ë”ë¸”, 3 = íŠ¸ë¦¬í”Œ
    };
  }

  function spawnStars(){
    stars = Array.from({length:G.starCount}, _=>({
      x:Math.random()*G.w,
      y:Math.random()*G.h,
      s: Math.random()*1.2+0.4
    }));
  }

  // Enemy spawner (grid + sine sway + dive)
  function spawnWave(n=32){
    enemies=[];
    const cols=8, rows=Math.ceil(n/cols);
    const gapX=70, gapY=48;
    const startX=(G.w - (cols-1)*gapX)/2, startY=90;
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        if(enemies.length>=n) break;
        const ex = startX + c*gapX;
        const ey = startY + r*gapY;
        const kind = (r===0?2:(r===1?1:0)); // ìƒë‹¨ì¼ìˆ˜ë¡ ìƒê¸‰
        enemies.push({
          x:ex, y:ey,
          baseX:ex, baseY:ey,
          t:Math.random()*Math.PI*2,
          hp:1 + Math.min(2, Math.floor((S.wave-1)/3)),
          kind,           // 0:blue,1:pink,2:gold
          alive:true,
          diving:false,
          diveTime:0,
          hasItem:false,
          squad:false
        });
      }
    }
    // ì´ë²ˆ ì›¨ì´ë¸Œì—ì„œ ì•„ì´í…œì„ ë“¤ê³  ë‚˜ì˜¬ ì  1ë§ˆë¦¬ ì„ ì •
    itemSpawnedThisWave = false;
    supportItem = null;
    if(enemies.length && !helper){
      const idx = Math.floor(Math.random()*enemies.length);
      enemies[idx].hasItem = true;
    }
    SND.wave();
  }

  function showWaveBanner(){
    waveBanner = {
      text: 'WAVE ' + S.wave,
      t: 0,
      dur: 1.4
    };
  }

  // í° ì ìˆ˜ì¼ ë•Œ íŒì—…
  function addScorePopup(x,y,amount){
    if(amount < 500) return;
    scorePops.push({
      x, y,
      text: '+' + amount,
      t: 0,
      dur: 0.9
    });
  }

  function startGame(full=true){
    if(full){
      S.score=0;
      S.wave=1;
      S.lives=3;
      S.ultCharges=0;
    }
    S.over=false;
    S.running=true;
    S.paused=false;

    helper = null;
    supportItem = null;
    waveTime = 0;
    itemSpawnedThisWave = false;
    boss = null;
    bossBullets = [];
    bossShotTimer = 0;
    bossBigTimer = 0;
    invulTime = 0;
    ultFlash = null;
    shakeTime = 0;

    resetPlayer();
    bullets=[];
    enemyBullets=[];
    explosions=[];
    scorePops=[];
    waveBanner=null;
    spawnStars();
    spawnWave(32);
    showWaveBanner();
    updateHUD();
  }

  function updateHUD(){
    hud.score.textContent=S.score;
    hud.wave.textContent=S.wave;
    hud.lives.textContent=S.lives;
    hud.best.textContent=S.best;
    hud.ult.textContent=S.ultCharges;
    btnPause.textContent = S.paused? 'ê³„ì†í•˜ê¸°' : 'ì¼ì‹œì •ì§€';
    btnMute.textContent =
      btnMute.getAttribute('aria-pressed')==='true'
        ? 'ğŸ”‡ ìŒì†Œê±° í•´ì œ'
        : 'ğŸ”Š ìŒì†Œê±°';
  }

  function gameOver(){
    S.over=true;
    S.running=false;
    S.paused=false;
  }

  // ===== Input =====
  window.addEventListener('keydown',e=>{
    const k=e.key;
    if(['ArrowLeft','ArrowRight',' ','p','P','b','B'].includes(k)) e.preventDefault();
    if(k==='ArrowLeft') S.keys.add('left');
    if(k==='ArrowRight') S.keys.add('right');
    if(k===' ') S.keys.add('fire');
    if(k==='p'||k==='P') togglePause();
    if(k==='b'||k==='B') activateUltimate();
  });
  window.addEventListener('keyup',e=>{
    const k=e.key;
    if(k==='ArrowLeft') S.keys.delete('left');
    if(k==='ArrowRight') S.keys.delete('right');
    if(k===' ') S.keys.delete('fire');
  });
  btLeft.addEventListener('pointerdown',()=>{ S.leftHold=true; });
  btRight.addEventListener('pointerdown',()=>{ S.rightHold=true; });
  btFire.addEventListener('pointerdown',()=>{ S.fireHold=true; });
  ['pointerup','pointerleave','pointercancel'].forEach(t=>{
    btLeft.addEventListener(t,()=>{ S.leftHold=false; });
    btRight.addEventListener(t,()=>{ S.rightHold=false; });
    btFire.addEventListener(t,()=>{ S.fireHold=false; });
  });
  btnStart.onclick=()=> startGame(true);
  btnPause.onclick=()=> togglePause();
  btnMute.onclick=()=>{
    const now = btnMute.getAttribute('aria-pressed')==='true';
    const next = !now;
    btnMute.setAttribute('aria-pressed', String(next));
    SND.setMuted(next);
    updateHUD();
  };
  function togglePause(){
    if(!S.running || S.over) return;
    S.paused=!S.paused;
    updateHUD();
  }

  // ===== Utils =====
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const dist=(x1,y1,x2,y2)=>Math.hypot(x2-x1, y2-y1);
  function rectCircleCollide(rx,ry,rw,rh,cx,cy,cr){
    const tx=clamp(cx,rx,rx+rw), ty=clamp(cy,ry,ry+rh);
    return (cx-tx)*(cx-tx)+(cy-ty)*(cy-ty) <= cr*cr;
  }

  // ===== PowerUp ì²´í¬ =====
  function checkPowerUp(oldScore, newScore, x, y){
    if(!player) return;
    // 1 â†’ 2 ë‹¨ê³„
    if(oldScore < 2000 && newScore >= 2000 && player.powerLevel < 2){
      player.powerLevel = 2;
      scorePops.push({
        x, y,
        text: 'POWER UP II',
        t: 0,
        dur: 1.2
      });
    }
    // 2 â†’ 3 ë‹¨ê³„
    if(oldScore < 6000 && newScore >= 6000 && player.powerLevel < 3){
      player.powerLevel = 3;
      scorePops.push({
        x, y,
        text: 'POWER UP III',
        t: 0,
        dur: 1.2
      });
    }
  }

  // ===== Gameplay =====

  // ê¶ê·¹ê¸° ë°œë™
  function activateUltimate(){
    if(!player || !S.running || S.over) return;
    if(S.ultCharges <= 0) return;

    // ì†Œë¹„
    S.ultCharges--;
    updateHUD();

    // 2ì´ˆ ë¬´ì 
    invulTime = Math.max(invulTime, 2.0);

    // í™”ë©´ì˜ ì  íƒ„/ë³´ìŠ¤ íƒ„ ì „ì²´ ì‚­ì œ
    enemyBullets.length = 0;
    bossBullets.length = 0;

    // í­íƒ„ íƒ„ë§‰ ì—°ì¶œ: í”Œë ˆì´ì–´ ê¸°ì¤€ ë°©ì‚¬í˜•
    const cx = player.x;
    const cy = player.y;

    const smallCount = 40;
    const midCount   = 24;

    // ì‘ì€ íƒ„ë“¤ (dmg 1)
    for(let i=0;i<smallCount;i++){
      const ang = (i/smallCount)*Math.PI*2 + (Math.random()-0.5)*0.2;
      const spd = 220 + Math.random()*140;
      bullets.push({
        x: cx,
        y: cy,
        r: 4,
        vx: Math.cos(ang)*spd,
        vy: Math.sin(ang)*spd,
        dmg: 1,
        ult: true
      });
    }
    // ì¤‘ê°„ í¬ê¸° íƒ„ë“¤ (dmg 2ë°°)
    for(let i=0;i<midCount;i++){
      const ang = (i/midCount)*Math.PI*2 + (Math.random()-0.5)*0.2;
      const spd = 180 + Math.random()*120;
      bullets.push({
        x: cx,
        y: cy,
        r: 6,
        vx: Math.cos(ang)*spd,
        vy: Math.sin(ang)*spd,
        dmg: 2,
        ult: true
      });
    }

    // í™”ë©´ í•˜ì–€ í”Œë˜ì‹œ
    ultFlash = { t:0, dur:0.6 };

    // ì§€ì§„(ì¹´ë©”ë¼ í”ë“¤ë¦¼)
    shakeTime = 0.5;

    // ì—°ì¶œìš© í…ìŠ¤íŠ¸
    scorePops.push({
      x: cx,
      y: cy - 50,
      text: 'ULTIMATE!',
      t: 0,
      dur: 1.2
    });
  }

  function fire(){
    if(!player) return;
    const now = performance.now()/1000;
    if(player.cool && now < player.cool) return;
    player.cool = now + G.player.cool;

    const base = {
      y: player.y - 18,
      r: G.bullet.r,
      vx: 0,
      vy: -G.bullet.speed,
      dmg: 1
    };

    let offsets;
    if(player.powerLevel >= 3){
      offsets = [-10, 0, 10];
    } else if(player.powerLevel === 2){
      offsets = [-6, 6];
    } else {
      offsets = [0];
    }

    // ë©”ì¸ ê¸°ì²´ ìƒ·
    for(const off of offsets){
      bullets.push({
        x: player.x + off,
        ...base
      });
    }

    // ì§€ì›ê¸° ìƒ· (ìˆìœ¼ë©´ ê°™ì€ íŒ¨í„´ìœ¼ë¡œ ë³µì‚¬)
    if(helper){
      for(const off of offsets){
        bullets.push({
          x: player.x + helper.offsetX + off,
          ...base
        });
      }
    }

    SND.shoot();
  }

  function enemyFire(e){
    enemyBullets.push({
      x:e.x,
      y:e.y+12,
      r:G.enemyBullet.r,
      vy:G.enemyBullet.speed,
      vx:0
    });
  }

  // ë³´ìŠ¤ ìƒì„±
  function spawnBoss(){
    enemies = [];
    bossBullets = [];
    const baseHp = 150;
    const base = {
      x: G.w/2,
      y: 140,
      hp: baseHp,
      maxHp: baseHp,
      targetX: G.w/2,
      targetY: 140,
      nextSummonHp: baseHp * 0.8,
      sideFlag: 1,  // ìŠ¤ì¿¼ë“œ ì†Œí™˜ ë°©í–¥ í† ê¸€ìš© (ìŠ¤í…Œì´ì§€3)
      sideMode: -1, // íŒ” ì‚¬ê²© ë°©í–¥ (-1: ì™¼ìª½, 1: ì˜¤ë¥¸ìª½)
      sideModeTime: 0
    };
    if(S.wave === 3){
      // ìŠ¤í…Œì´ì§€3 ë³´ìŠ¤ (ë¡œë´‡í˜•)
      boss = {
        ...base,
        type: 3,
        w: 210,
        h: 80,
        speed: 50
      };
    } else {
      // ìŠ¤í…Œì´ì§€4 ë³´ìŠ¤
      boss = {
        ...base,
        type: 4,
        w: 220,
        h: 90,
        speed: 60
      };
    }
    bossShotTimer = 0;
    bossBigTimer = 1.8;
  }

  // ë³´ìŠ¤ê°€ í˜¸ì¶œí•˜ëŠ” ëŒ€ê°ì„  ìŠ¤ì¿¼ë“œ(ê¸°ë³¸ ì êµ°)
  function spawnBossMinions(){
    const baseHp = 1 + Math.min(2, Math.floor((S.wave-1)/3));
    if(boss && boss.type === 3){
      // ìŠ¤í…Œì´ì§€3: 4ë§ˆë¦¬ê°€ í•œìª½ì—ì„œ 30ë„ ê°ë„ ë²”ìœ„ë¡œ ëŒ€ê°ì„  ì§„ì…
      const count = 4;
      const baseY = -40;
      const fromRight = boss.sideFlag === 1;
      const startX = fromRight ? (G.w + 40) : -40;
      const baseAng = Math.PI/2 + (fromRight ? Math.PI/6 : -Math.PI/6); // ì•„ë˜ì—ì„œ ì¢Œ/ìš°ë¡œ 30ë„ ê¸°ìš¸ì–´ì§„ ë°©í–¥
      const spread = Math.PI/12; // Â±15ë„
      for(let i=0;i<count;i++){
        const y = baseY - Math.random()*60;
        const ang = baseAng + (Math.random()-0.5)*2*spread;
        const spd = 190 + Math.random()*40;
        enemies.push({
          x: startX,
          y,
          baseX: 0,
          baseY: 0,
          t: 0,
          hp: baseHp,
          kind: 1,
          alive: true,
          diving: false,
          diveTime: 0,
          hasItem: false,
          squad: true,
          vx: Math.cos(ang)*spd,
          vy: Math.sin(ang)*spd
        });
      }
      // ë‹¤ìŒ ì†Œí™˜ì€ ë°˜ëŒ€ ë°©í–¥
      boss.sideFlag *= -1;
    } else {
      // ìŠ¤í…Œì´ì§€4: ì–‘ìª½ì—ì„œ 3ë§ˆë¦¬ì”© ê¸°ì¡´ ëŒ€ê°ì„  íŒ¨í„´
      const rows = 3;
      const gapY = 32;
      const baseY = -40;
      for(let i=0;i<rows;i++){
        const y = baseY - i*gapY;
        // ì™¼ìª½ â†’ ì˜¤ë¥¸ìª½ ì•„ë˜ ëŒ€ê°ì„ 
        enemies.push({
          x: -50 - i*10,
          y,
          baseX: 0,
          baseY: 0,
          t: 0,
          hp: baseHp,
          kind: 1,
          alive: true,
          diving: false,
          diveTime: 0,
          hasItem: false,
          squad: true,
          vx: 140,
          vy: 160
        });
        // ì˜¤ë¥¸ìª½ â†’ ì™¼ìª½ ì•„ë˜ ëŒ€ê°ì„ 
        enemies.push({
          x: G.w + 50 + i*10,
          y,
          baseX: 0,
          baseY: 0,
          t: 0,
          hp: baseHp,
          kind: 0,
          alive: true,
          diving: false,
          diveTime: 0,
          hasItem: false,
          squad: true,
          vx: -140,
          vy: 160
        });
      }
    }
  }

  // ë³´ìŠ¤ ì´ë™ ë° íƒ„ë§‰ íŒ¨í„´
  function updateBoss(dt){
    if(!boss || S.over) return;
    // ëŠë¦° ì†ë„ë¡œ ìƒë‹¨ ì˜ì—­ ì•ˆì—ì„œ ë¬´ì‘ìœ„ ì´ë™
    const marginX = 80;
    const minY = 80;
    const maxY = 220;
    if(!boss.targetX || (Math.abs(boss.x - boss.targetX) < 4 && Math.abs(boss.y - boss.targetY) < 4)){
      boss.targetX = marginX + Math.random()*(G.w - marginX*2);
      boss.targetY = minY + Math.random()*(maxY - minY);
    }
    const dx = boss.targetX - boss.x;
    const dy = boss.targetY - boss.y;
    const distMove = Math.hypot(dx, dy);
    if(distMove > 1){
      const v = boss.speed * dt;
      boss.x += dx/distMove * v;
      boss.y += dy/distMove * v;
    }

    if(boss.type === 3){
      // ìŠ¤í…Œì´ì§€3: íŒ”ì—ì„œ ì‘ì€ íƒ„, ê°€ìš´ë°ì„œ í° íƒ„ (ì¢Œ/ìš° 4ì´ˆì”© ë²ˆê°ˆì•„ ì‚¬ê²©)
      // ì¢Œ/ìš° íŒ” ì‚¬ê²© ëª¨ë“œ ì „í™˜
      boss.sideModeTime += dt;
      if(boss.sideModeTime >= 4){
        boss.sideModeTime = 0;
        boss.sideMode *= -1; // -1 â†” 1
      }
      bossShotTimer -= dt;
      if(bossShotTimer <= 0){
        // ë°œì‚¬ ë¹ˆë„ìˆ˜
        bossShotTimer = 0.24;
        const rx = boss.w * 0.5;
        const armY = boss.h * 0.15;
        const left = { x: boss.x - rx*0.7, y: boss.y + armY };
        const right = { x: boss.x + rx*0.7, y: boss.y + armY };
        const base = Math.PI/2;
        const spread = Math.PI/6; // ì´ 60ë„ ë²”ìœ„
        const useLeft = boss.sideMode < 0;
        if(useLeft){
          const ang = base + (Math.random()-0.5)*2*spread;
          const spd = 200 + Math.random()*50;
          bossBullets.push({
            x: left.x,
            y: left.y,
            vx: Math.cos(ang)*spd,
            vy: Math.sin(ang)*spd,
            r: 3
          });
        } else {
          const ang = base + (Math.random()-0.5)*2*spread;
          const spd = 200 + Math.random()*50;
          bossBullets.push({
            x: right.x,
            y: right.y,
            vx: Math.cos(ang)*spd,
            vy: Math.sin(ang)*spd,
            r: 3
          });
        }
      }
      // ì¤‘ì•™ í° íƒ„ (ìˆ˜ë¥˜íƒ„ì²˜ëŸ¼ ëì—ì„œ í„°ì§€ëŠ” íƒ„)
      bossBigTimer -= dt;
      if(bossBigTimer <= 0){
        bossBigTimer = 3.2; // ë°œì‚¬ ê°„ê²©
        const ang = Math.PI/2 + (Math.random()-0.5)*0.2;
        const spd = 230; // ì†ë„
        bossBullets.push({
          x: boss.x,
          y: boss.y,
          vx: Math.cos(ang)*spd,
          vy: Math.sin(ang)*spd,
          r: 11,
          big: true
        });
      }
    } else {
      // ìŠ¤í…Œì´ì§€4: ì‚¬ë°©ìœ¼ë¡œ ëœë¤ íƒ„ í©ë¿Œë¦¬ê¸°
      bossShotTimer -= dt;
      if(bossShotTimer <= 0){
        const volley = 18;
        for(let i=0;i<volley;i++){
          const ang = Math.random()*Math.PI*2;
          const spd = 140 + Math.random()*100;
          bossBullets.push({
            x: boss.x,
            y: boss.y,
            vx: Math.cos(ang)*spd,
            vy: Math.sin(ang)*spd,
            r: G.enemyBullet.r
          });
        }
        bossShotTimer = 0.9;
      }
    }
  }

  function nextWave(){
    S.wave++;
    // ì›¨ì´ë¸Œ ë„˜ì–´ê°€ë„ íŒŒì›ŒëŠ” ìœ ì§€
    const prevPower = player ? player.powerLevel : 1;
    waveTime = 0;
    supportItem = null;
    itemSpawnedThisWave = false;
    resetPlayer();
    player.powerLevel = prevPower; // ì´ì „ íŒŒì›Œ ë³µêµ¬
    bullets=[];
    enemyBullets=[];
    explosions=[];
    boss = null;
    bossBullets = [];
    bossShotTimer = 0;
    bossBigTimer = 0;
    if(S.wave === 3 || S.wave === 4){
      spawnBoss();
    } else {
      spawnWave(32 + Math.min(32, (S.wave-1)*4));
    }
    showWaveBanner();
    updateHUD();
  }

  // ì¬í•©ë¥˜: í™”ë©´ ì•„ë˜ë¡œ ë‚˜ê°€ë©´ ìœ„ì—ì„œ í¸ëŒ€ë¡œ ë³µê·€
  function rejoinTop(e){
    e.diving=false;
    e.diveTime=0;
    e.y = -40;
  }

  function step(dt, t){
    // ì›¨ì´ë¸Œ ê²½ê³¼ì‹œê°„
    waveTime += dt;
    // ë¬´ì  ì‹œê°„ ê°ì†Œ
    if(invulTime > 0){
      invulTime -= dt;
      if(invulTime < 0) invulTime = 0;
    }
    // ê¶ê·¹ê¸° í”Œë˜ì‹œ/ì§€ì§„ íƒ€ì´ë¨¸ ê°ì†Œ
    if(ultFlash){
      ultFlash.t += dt;
      if(ultFlash.t > ultFlash.dur) ultFlash = null;
    }
    if(shakeTime > 0){
      shakeTime -= dt;
      if(shakeTime < 0) shakeTime = 0;
    }

    // ë³„
    for(let s of stars){
      s.y += s.s*40*dt;
      if(s.y>G.h){
        s.y-=G.h;
        s.x=Math.random()*G.w;
      }
    }

    // ì…ë ¥
    const moveLeft = S.keys.has('left') || S.leftHold;
    const moveRight = S.keys.has('right') || S.rightHold;
    const fireKey = S.keys.has('fire') || S.fireHold;
    if(player){
      if(moveLeft && !moveRight) player.x -= G.player.speed*dt;
      if(moveRight && !moveLeft) player.x += G.player.speed*dt;
      player.x = clamp(player.x, 20, G.w-20);
      if(fireKey) fire();
    }

    // ì§€ì›ê¸° ìœ„ì¹˜ë¥¼ í”Œë ˆì´ì–´ ì˜¤ë¥¸ìª½ì— ê³ ì •
    if(helper && player){
      helper.x = player.x + helper.offsetX;
      helper.y = player.y;
    }

    // ì§€ì› ì•„ì´í…œ ì´ë™ + ë¨¹ê¸°
    if(supportItem){
      supportItem.y += supportItem.vy * dt;
      if(supportItem.y > G.h + 20){
        supportItem = null;
      } else if(player && rectCircleCollide(
        player.x-14, player.y-10, 28, 20,
        supportItem.x, supportItem.y, supportItem.r
      )){
        // ì•„ì´í…œ íšë“ â†’ ì§€ì›ê¸° ìƒê¹€
        helper = { offsetX: 40, x: player.x + 40, y: player.y };
        supportItem = null;
        scorePops.push({
          x: player.x + 40,
          y: player.y - 30,
          text: 'ALLY ON!',
          t: 0,
          dur: 1.1
        });
      }
    }

    // í”Œë ˆì´ì–´ íƒ„
    for(let i=bullets.length-1;i>=0;i--){
      const b=bullets[i];
      const vx = b.vx || 0;
      b.x += vx * dt;
      b.y += b.vy*dt;
      if(b.y<-20 || b.y>G.h+20 || b.x<-20 || b.x>G.w+20){
        bullets.splice(i,1);
        continue;
      }
      let hit = false;
      const dmg = b.dmg || 1;

      // ì¼ë°˜ ì ê³¼ ì¶©ëŒ
      for(let j=enemies.length-1;j>=0;j--){
        const e=enemies[j];
        if(!e.alive) continue;
        if(dist(b.x,b.y,e.x,e.y) < 16){
          bullets.splice(i,1);
          hit = true;
          e.hp -= dmg;
          if(e.hp<=0){
            e.alive=false;
            explosions.push({x:e.x,y:e.y,t:0});
            const gain = 100 + e.kind*50;
            const before = S.score;
            S.score += gain;
            addScorePopup(e.x, e.y, gain);
            checkPowerUp(before, S.score, e.x, e.y);
            SND.hit();
            if(S.score>S.best){
              S.best=S.score;
              try{
                localStorage.setItem(SAVE_KEY, String(S.best));
              }catch(err){}
            }
            // ì•„ì´í…œ ë³´ìœ  ì ì´ë©´ ì•„ì´í…œ ë“œë (ì§€ì›ê¸°)
            if(e.hasItem && !helper && !supportItem){
              supportItem = {
                x: e.x,
                y: e.y,
                r: 10,
                vy: 60
              };
              itemSpawnedThisWave = true;
            }
            // ê¶ê·¹ê¸° ê²Œì´ì§€ 1% í™•ë¥  ë“œë (ì¦‰ì‹œ íšë“)
            if(Math.random() < 0.01 && S.ultCharges < 3){
              S.ultCharges++;
              scorePops.push({
                x: e.x,
                y: e.y - 20,
                text: 'ULT +1',
                t: 0,
                dur: 1.0
              });
              updateHUD();
            }
          }
          break;
        }
      }
      if(hit) continue;

      // ë³´ìŠ¤ì™€ ì¶©ëŒ
      if(boss){
        const dx = b.x - boss.x;
        const dy = b.y - boss.y;
        if(Math.abs(dx) < boss.w*0.5 && Math.abs(dy) < boss.h*0.5){
          bullets.splice(i,1);
          hit = true;
          boss.hp -= dmg;
          explosions.push({x:b.x,y:b.y,t:0});
          SND.hit();
          // ì²´ë ¥ 20% ë‹¨ìœ„ë¡œ ìŠ¤ì¿¼ë“œ ì†Œí™˜
          if(boss.hp > 0 && boss.hp <= boss.nextSummonHp){
            spawnBossMinions();
            boss.nextSummonHp -= boss.maxHp * 0.2;
          }
          // ë³´ìŠ¤ ê²©íŒŒ
          if(boss.hp <= 0){
            explosions.push({x:boss.x,y:boss.y,t:0});
            const gain = 5000;
            const before = S.score;
            S.score += gain;
            addScorePopup(boss.x, boss.y, gain);
            checkPowerUp(before, S.score, boss.x, boss.y);
            if(S.score>S.best){
              S.best=S.score;
              try{
                localStorage.setItem(SAVE_KEY, String(S.best));
              }catch(err){}
            }
            boss = null;
            bossBullets = [];
          }
        }
      }
    }

    // ì  íƒ„
    if(player){
      for(let i=enemyBullets.length-1;i>=0;i--){
        const eb=enemyBullets[i];
        const vx = eb.vx || 0;
        eb.x += vx*dt;
        eb.y += eb.vy*dt;
        if(eb.y>G.h+20 || eb.y<-40 || eb.x<-40 || eb.x>G.w+40){
          enemyBullets.splice(i,1);
          continue;
        }
        if(rectCircleCollide(
          player.x-14,player.y-10,28,20,
          eb.x,eb.y,eb.r
        )){
          enemyBullets.splice(i,1);
          if(invulTime <= 0) hitPlayer();
          continue;
        }
        // ì§€ì›ê¸° í”¼ê²©
        if(helper && rectCircleCollide(
          helper.x-14, helper.y-10, 28, 20,
          eb.x, eb.y, eb.r
        )){
          enemyBullets.splice(i,1);
          explosions.push({x:helper.x,y:helper.y,t:0});
          SND.hit();
          helper = null;
          continue;
        }
      }
    }

    // ë³´ìŠ¤ íƒ„
    if(player){
      for(let i=bossBullets.length-1;i>=0;i--){
        const eb=bossBullets[i];
        eb.x += eb.vx*dt;
        eb.y += eb.vy*dt;
        // í° íƒ„(ìˆ˜ë¥˜íƒ„í˜•)ì´ ë§µ ëì— ë‹¿ì•˜ì„ ë•Œ í„°ì§€ë©´ì„œ íƒ„ë§‰ ë°©ì‚¬
        if(eb.big){
          const hitEdge =
            (eb.x <= 0 || eb.x >= G.w || eb.y <= 0 || eb.y >= G.h);
          if(hitEdge){
            const cx = Math.max(20, Math.min(G.w-20, eb.x));
            const cy = Math.max(20, Math.min(G.h-20, eb.y));
            explosions.push({x:cx,y:cy,t:0});
            const count = 18;
            for(let k=0;k<count;k++){
              const ang = Math.random()*Math.PI*2;
              const spd = 130 + Math.random()*120;
              const rad = (k % 2 === 0) ? 3 : 5;
              bossBullets.push({
                x: cx,
                y: cy,
                vx: Math.cos(ang)*spd,
                vy: Math.sin(ang)*spd,
                r: rad
              });
            }
            bossBullets.splice(i,1);
            continue;
          }
        }
        if(eb.x < -40 || eb.x > G.w+40 || eb.y < -40 || eb.y > G.h+40){
          bossBullets.splice(i,1);
          continue;
        }
        // í”Œë ˆì´ì–´ í”¼ê²©
        if(rectCircleCollide(
          player.x-14,player.y-10,28,20,
          eb.x,eb.y,eb.r
        )){
          bossBullets.splice(i,1);
          if(invulTime <= 0) hitPlayer();
          continue;
        }
        // ì§€ì›ê¸° í”¼ê²©
        if(helper && rectCircleCollide(
          helper.x-14, helper.y-10, 28, 20,
          eb.x, eb.y, eb.r
        )){
          bossBullets.splice(i,1);
          explosions.push({x:helper.x,y:helper.y,t:0});
          SND.hit();
          helper = null;
          continue;
        }
      }
    }

    // ì  ì´ë™/í–‰ë™
    const sway = 26 + Math.min(40, S.wave*2);
    const speed = 12 + S.wave*2;
    const diveOdds = Math.min(0.25, 0.05 + S.wave*0.01);
    let liveCount=0;

    // ë‹¤ì´ë¸Œ ì‹œì‘ (ë³´ìŠ¤ ì†Œí™˜ ìŠ¤ì¿¼ë“œëŠ” ì œì™¸)
    if(Math.random() < diveOdds*dt && enemies.length){
      const cand = enemies.filter(e=>e.alive && !e.diving && !e.squad);
      if(cand.length){
        const e = cand[Math.floor(Math.random()*cand.length)];
        e.diving = true;
        e.diveTime = 0;
      }
    }

    for(let e of enemies){
      if(!e.alive) continue;
      liveCount++;
      // ë³´ìŠ¤ ìŠ¤ì¿¼ë“œ(ëŒ€ê°ì„ ìœ¼ë¡œ ê°€ë¡œì§€ë¥´ëŠ” ì ë“¤)
      if(e.squad){
        e.x += e.vx*dt;
        e.y += e.vy*dt;
        if(player && Math.random() < 0.9*dt){
          enemyFire(e);
        }
        // í™”ë©´ ë°–ìœ¼ë¡œ ì™„ì „íˆ ë‚˜ê°€ë©´ ì œê±°
        if(e.y > G.h + 60 || e.x < -80 || e.x > G.w + 80){
          e.alive = false;
        }
        continue;
      }

      if(!e.diving){
        // í¸ëŒ€ ì´ë™
        e.t += dt*(0.8 + e.kind*0.2);
        e.x = e.baseX + Math.sin(e.t*speed*0.08 + e.baseY*0.02)*sway;
        e.y += (e.baseY - e.y) * dt * 2.5;
        if(Math.abs(e.y - e.baseY) < 0.5) e.y = e.baseY;
        // ì‚¬ê²©
        if(Math.random() < (0.35 + e.kind*0.15 + S.wave*0.01)*dt){
          if(player && Math.abs(e.x - player.x) < 160) enemyFire(e);
        }
      } else {
        // ë‹¤ì´ë¸Œ
        e.diveTime += dt;
        const u = e.diveTime;
        const px = player ? player.x : G.w/2;
        e.x += (px - e.x)*dt*0.9 + Math.sin(u*8)*40*dt;
        e.y += 120*dt + u*60*dt;
        if(player && dist(e.x,e.y,player.x,player.y) < 20){
          // ì•„ì´í…œ ë“  ì ì´ ëŒì§„ ì¤‘ í”Œë ˆì´ì–´ì™€ ì¶©ëŒí–ˆì„ ë•Œë„ ë“œë
          if(e.hasItem && !helper && !supportItem){
            supportItem = {
              x: e.x,
              y: e.y,
              r: 10,
              vy: 60
            };
            itemSpawnedThisWave = true;
          }
          e.alive=false;
          explosions.push({x:e.x,y:e.y,t:0});
          if(invulTime <= 0) hitPlayer();
        }
        if(Math.random() < 0.5*dt) enemyFire(e);
      }
      // í™”ë©´ ì•„ë˜ â†’ ìœ„ì—ì„œ ì¬í•©ë¥˜
      if(e.y > G.h + 40){
        rejoinTop(e);
      }
      if(e.y < -80){
        e.y = -40;
      }
    }

    // ë³´ìŠ¤ ì´ë™/ê³µê²© ì—…ë°ì´íŠ¸
    updateBoss(dt);
    // ë³´ìŠ¤ë„ ìƒì¡´ ì¹´ìš´íŠ¸ì— í¬í•¨
    if(boss && !S.over){
      liveCount++;
    }

    // ì´í™íŠ¸
    for(let i=explosions.length-1;i>=0;i--){
      const ex=explosions[i];
      ex.t += dt;
      if(ex.t>0.4) explosions.splice(i,1);
    }

    // ì›¨ì´ë¸Œ ë°°ë„ˆ/ì ìˆ˜ íŒì—… íƒ€ì´ë¨¸
    if(waveBanner){
      waveBanner.t += dt;
      if(waveBanner.t > waveBanner.dur) waveBanner = null;
    }
    for(let i=scorePops.length-1;i>=0;i--){
      const p=scorePops[i];
      p.t += dt;
      if(p.t > p.dur) scorePops.splice(i,1);
    }

    // ëª¨ë‘ ê²©ì¶” â†’ ë‹¤ìŒ ì›¨ì´ë¸Œ (ë³´ìŠ¤ê°€ ì—†ì„ ë•Œë§Œ)
    if(liveCount===0 && !boss){
      nextWave();
    }
  }

  function hitPlayer(){
    if(player){
      explosions.push({x:player.x,y:player.y,t:0});
    }
    SND.die();
    S.lives--;
    helper = null; // í”¼ê²© ì‹œ ì§€ì›ê¸° ì œê±°
    updateHUD();
    if(S.lives<=0){
      gameOver();
      return;
    }
    bullets=[];
    enemyBullets=[];
    if(player){
      player.x=G.w/2;
      player.y=G.player.y;
      player.cool=0;
    }
    // ë¶€í™œ í›„ ì ì‹œ ë¬´ì 
    invulTime = 1.5;
  }

  // ===== Render helpers =====
  function drawPlayerShip(){
    if(!player || S.over) return;
    CTX.save();
    if(invulTime > 0){
      const phase = Math.floor(invulTime * 10);
      CTX.globalAlpha = (phase % 2 === 0) ? 0.35 : 1;
    }
    CTX.translate(player.x, player.y);
    // ë©”ì¸ ê¸°ì²´ ë°”ë””
    const grad = CTX.createLinearGradient(0,-18,0,16);
    grad.addColorStop(0, '#e3fff9');
    grad.addColorStop(0.35, '#8ef6d0');
    grad.addColorStop(1, '#0e8c64');
    CTX.fillStyle = grad;
    CTX.beginPath();
    CTX.moveTo(0,-18);
    CTX.lineTo(-12,0);
    CTX.lineTo(-8,14);
    CTX.lineTo(0,10);
    CTX.lineTo(8,14);
    CTX.lineTo(12,0);
    CTX.closePath();
    CTX.fill();
    CTX.lineWidth = 1.5;
    CTX.strokeStyle = '#053427';
    CTX.stroke();
    // ë‚ ê°œ
    const wingGrad = CTX.createLinearGradient(-20,0,20,0);
    wingGrad.addColorStop(0,'#1b3650');
    wingGrad.addColorStop(0.5,'#112031');
    wingGrad.addColorStop(1,'#1b3650');
    CTX.fillStyle = wingGrad;
    CTX.beginPath();
    CTX.moveTo(-20,2);
    CTX.lineTo(-6,-3);
    CTX.lineTo(-4,8);
    CTX.lineTo(-16,14);
    CTX.closePath();
    CTX.moveTo(20,2);
    CTX.lineTo(6,-3);
    CTX.lineTo(4,8);
    CTX.lineTo(16,14);
    CTX.closePath();
    CTX.fill();
    // ì¡°ì¢…ì„ ìœ ë¦¬
    const cockRad = CTX.createRadialGradient(0,-4,0,0,-4,10);
    cockRad.addColorStop(0,'rgba(180,240,255,0.9)');
    cockRad.addColorStop(0.6,'rgba(70,180,255,0.7)');
    cockRad.addColorStop(1,'rgba(5,40,90,0.2)');
    CTX.fillStyle = cockRad;
    CTX.beginPath();
    CTX.ellipse(0,-4,7,5,0,0,Math.PI*2);
    CTX.fill();
    // ì—”ì§„ ë°œê´‘
    CTX.globalAlpha = 0.7;
    const engGrad = CTX.createRadialGradient(0,14,0,0,14,10);
    engGrad.addColorStop(0,'rgba(63,255,210,1)');
    engGrad.addColorStop(0.5,'rgba(63,255,210,0.3)');
    engGrad.addColorStop(1,'rgba(63,255,210,0)');
    CTX.fillStyle = engGrad;
    CTX.beginPath();
    CTX.ellipse(0,16,6,4,0,0,Math.PI*2);
    CTX.fill();
    CTX.globalAlpha = 1;
    // ì—”ì§„ ë¶ˆê½ƒ
    CTX.beginPath();
    CTX.moveTo(0,16);
    CTX.lineTo(-3,24);
    CTX.lineTo(0,30);
    CTX.lineTo(3,24);
    CTX.closePath();
    const flameGrad = CTX.createLinearGradient(0,16,0,30);
    flameGrad.addColorStop(0,'#ffe066');
    flameGrad.addColorStop(1,'#ff4b4b');
    CTX.fillStyle = flameGrad;
    CTX.fill();
    // ë°”ë‹¥ ê·¸ë¦¼ì
    CTX.globalAlpha = 0.35;
    CTX.fillStyle = '#3bf6c7';
    CTX.beginPath();
    CTX.ellipse(0,18,14,5,0,0,Math.PI*2);
    CTX.fill();
    CTX.globalAlpha = 1;
    CTX.restore();
  }

  function drawHelperShip(){
    if(!helper || !player || S.over) return;
    const x = helper.x;
    const y = helper.y;
    CTX.save();
    CTX.translate(x, y);
    const grad = CTX.createLinearGradient(0,-18,0,16);
    grad.addColorStop(0, '#f3f0ff');
    grad.addColorStop(0.35, '#b2c4ff');
    grad.addColorStop(1, '#3246aa');
    CTX.fillStyle = grad;
    CTX.beginPath();
    CTX.moveTo(0,-18);
    CTX.lineTo(-12,0);
    CTX.lineTo(-8,14);
    CTX.lineTo(0,10);
    CTX.lineTo(8,14);
    CTX.lineTo(12,0);
    CTX.closePath();
    CTX.fill();
    CTX.lineWidth = 1.5;
    CTX.strokeStyle = '#141b4a';
    CTX.stroke();
    const cockRad = CTX.createRadialGradient(0,-4,0,0,-4,10);
    cockRad.addColorStop(0,'rgba(230,240,255,0.9)');
    cockRad.addColorStop(0.6,'rgba(130,170,255,0.7)');
    cockRad.addColorStop(1,'rgba(5,20,70,0.2)');
    CTX.fillStyle = cockRad;
    CTX.beginPath();
    CTX.ellipse(0,-4,7,5,0,0,Math.PI*2);
    CTX.fill();
    CTX.globalAlpha = 0.7;
    const engGrad = CTX.createRadialGradient(0,14,0,0,14,10);
    engGrad.addColorStop(0,'rgba(150,200,255,1)');
    engGrad.addColorStop(0.5,'rgba(150,200,255,0.3)');
    engGrad.addColorStop(1,'rgba(150,200,255,0)');
    CTX.fillStyle = engGrad;
    CTX.beginPath();
    CTX.ellipse(0,16,6,4,0,0,Math.PI*2);
    CTX.fill();
    CTX.globalAlpha = 1;
    CTX.restore();
  }

  function drawEnemyShip(e){
    const colMain = e.kind===2 ? '#ffd685' : (e.kind===1 ? '#ff8fa5' : '#7aa2ff');
    const colEdge = e.kind===2 ? '#f5b432' : (e.kind===1 ? '#d9366f' : '#3250ff');
    const eyeColor = e.kind===2 ? '#2b1b08' : '#0b1020';
    CTX.save();
    CTX.translate(e.x, e.y);
    const bodyGrad = CTX.createLinearGradient(0,-12,0,12);
    bodyGrad.addColorStop(0, '#ffffff');
    bodyGrad.addColorStop(0.3, colMain);
    bodyGrad.addColorStop(1, '#2b2448');
    CTX.fillStyle = bodyGrad;
    CTX.beginPath();
    CTX.moveTo(0,-14);
    CTX.quadraticCurveTo(-10,-10,-12,0);
    CTX.quadraticCurveTo(-10,12,0,14);
    CTX.quadraticCurveTo(10,12,12,0);
    CTX.quadraticCurveTo(10,-10,0,-14);
    CTX.closePath();
    CTX.fill();
    CTX.lineWidth=1.4;
    CTX.strokeStyle=colEdge;
    CTX.stroke();
    const wingGrad = CTX.createLinearGradient(-18,0,18,0);
    wingGrad.addColorStop(0, 'rgba(255,255,255,0.05)');
    wingGrad.addColorStop(0.5, 'rgba(255,255,255,0.18)');
    wingGrad.addColorStop(1, 'rgba(255,255,255,0.05)');
    CTX.fillStyle = wingGrad;
    CTX.beginPath();
    CTX.moveTo(-18,2);
    CTX.quadraticCurveTo(-10,-4,-4,-1);
    CTX.quadraticCurveTo(-10,6,-16,10);
    CTX.closePath();
    CTX.moveTo(18,2);
    CTX.quadraticCurveTo(10,-4,4,-1);
    CTX.quadraticCurveTo(10,6,16,10);
    CTX.closePath();
    CTX.fill();
    CTX.fillStyle = eyeColor;
    CTX.beginPath();
    CTX.arc(-6,-3,3.3,0,Math.PI*2);
    CTX.arc(6,-3,3.3,0,Math.PI*2);
    CTX.fill();
    CTX.fillStyle='#f5f5ff';
    CTX.beginPath();
    CTX.arc(-5.4,-3.7,1.3,0,Math.PI*2);
    CTX.arc(6.6,-3.7,1.3,0,Math.PI*2);
    CTX.fill();
    const coreGrad = CTX.createRadialGradient(0,4,0,0,4,6);
    coreGrad.addColorStop(0,'#fff7ea');
    coreGrad.addColorStop(0.4, colMain);
    coreGrad.addColorStop(1,'rgba(0,0,0,0)');
    CTX.fillStyle = coreGrad;
    CTX.beginPath();
    CTX.arc(0,4,6,0,Math.PI*2);
    CTX.fill();
    CTX.globalAlpha = 0.4;
    const trailGrad = CTX.createRadialGradient(0,10,0,0,10,14);
    trailGrad.addColorStop(0,colMain);
    trailGrad.addColorStop(1,'rgba(0,0,0,0)');
    CTX.fillStyle = trailGrad;
    CTX.beginPath();
    CTX.arc(0,10,14,0,Math.PI*2);
    CTX.fill();
    CTX.globalAlpha = 1;
    CTX.restore();
  }

  function drawBullet(b){
    CTX.save();
    CTX.translate(b.x, b.y);
    const r = b.r || 5;
    const g = CTX.createRadialGradient(0,0,0,0,0,r);
    g.addColorStop(0,'#fff9e6');
    g.addColorStop(0.4,C.bullet);
    g.addColorStop(1,'rgba(0,0,0,0)');
    CTX.fillStyle = g;
    CTX.beginPath();
    CTX.arc(0,0,r,0,Math.PI*2);
    CTX.fill();
    CTX.restore();
  }

  function drawEnemyBullet(eb){
    CTX.save();
    CTX.translate(eb.x, eb.y);
    const r = eb.r || 5;
    const g = CTX.createRadialGradient(0,0,0,0,0,r);
    g.addColorStop(0,'#ffe6f0');
    g.addColorStop(0.4,C.enemyShot);
    g.addColorStop(1,'rgba(0,0,0,0)');
    CTX.fillStyle = g;
    CTX.beginPath();
    CTX.arc(0,0,r,0,Math.PI*2);
    CTX.fill();
    CTX.restore();
  }

  function drawBossShip(){
    if(!boss) return;
    CTX.save();
    CTX.translate(boss.x, boss.y);
    if(boss.type === 3){
      // ìŠ¤í…Œì´ì§€3: ë¡œë´‡í˜• ì‹¤ë£¨ì—£ ë³´ìŠ¤
      const rx = boss.w * 0.5;
      const ry = boss.h * 0.5;
      // ëª¸í†µ
      const bodyGrad = CTX.createLinearGradient(-rx, -ry, rx, ry);
      bodyGrad.addColorStop(0,'#1b2434');
      bodyGrad.addColorStop(0.5,'#3f5875');
      bodyGrad.addColorStop(1,'#101624');
      CTX.fillStyle = bodyGrad;
      CTX.beginPath();
      CTX.moveTo(-rx*0.6, -ry*0.6);
      CTX.lineTo( rx*0.6, -ry*0.6);
      CTX.lineTo( rx*0.8,  0);
      CTX.lineTo( rx*0.5,  ry*0.7);
      CTX.lineTo(-rx*0.5,  ry*0.7);
      CTX.lineTo(-rx*0.8,  0);
      CTX.closePath();
      CTX.fill();
      CTX.strokeStyle = '#8fb3ff';
      CTX.lineWidth = 2;
      CTX.stroke();
      // ì–´ê¹¨ ì•„ë¨¸
      CTX.fillStyle = '#22324a';
      CTX.beginPath();
      CTX.moveTo(-rx*0.9, -ry*0.2);
      CTX.lineTo(-rx*0.4, -ry*0.5);
      CTX.lineTo(-rx*0.1, -ry*0.5);
      CTX.lineTo(-rx*0.3, -ry*0.1);
      CTX.closePath();
      CTX.fill();
      CTX.beginPath();
      CTX.moveTo(rx*0.9, -ry*0.2);
      CTX.lineTo(rx*0.4, -ry*0.5);
      CTX.lineTo(rx*0.1, -ry*0.5);
      CTX.lineTo(rx*0.3, -ry*0.1);
      CTX.closePath();
      CTX.fill();
      // íŒ”
      CTX.strokeStyle = '#9ad5ff';
      CTX.lineWidth = 3;
      CTX.beginPath();
      CTX.moveTo(-rx*0.55, -ry*0.1);
      CTX.lineTo(-rx*0.95, ry*0.2);
      CTX.lineTo(-rx*0.8, ry*0.35);
      CTX.moveTo(rx*0.55, -ry*0.1);
      CTX.lineTo(rx*0.95, ry*0.2);
      CTX.lineTo(rx*0.8, ry*0.35);
      CTX.stroke();
      // ì¤‘ì•™ ì½”ì–´
      const core = CTX.createRadialGradient(0,0,0,0,0,ry*0.25);
      core.addColorStop(0,'#e9fbff');
      core.addColorStop(1,'#34d3ff');
      CTX.fillStyle = core;
      CTX.beginPath();
      CTX.moveTo(-rx*0.18, -ry*0.05);
      CTX.lineTo( rx*0.18, -ry*0.05);
      CTX.lineTo( rx*0.26, ry*0.25);
      CTX.lineTo(-rx*0.26, ry*0.25);
      CTX.closePath();
      CTX.fill();
      // ë¨¸ë¦¬
      CTX.fillStyle = '#182132';
      CTX.beginPath();
      CTX.moveTo(-rx*0.25, -ry*0.6);
      CTX.lineTo( rx*0.25, -ry*0.6);
      CTX.lineTo( rx*0.18, -ry*0.3);
      CTX.lineTo(-rx*0.18, -ry*0.3);
      CTX.closePath();
      CTX.fill();
      // ëˆˆ
      CTX.fillStyle = '#54f0ff';
      CTX.fillRect(-rx*0.16, -ry*0.42, rx*0.12, ry*0.08);
      CTX.fillRect( rx*0.04, -ry*0.42, rx*0.12, ry*0.08);
    } else {
      // ìŠ¤í…Œì´ì§€4: íƒ€ì›í˜• ë³´ìŠ¤
      const rx = boss.w * 0.5;
      const ry = boss.h * 0.5;
      const bodyGrad = CTX.createLinearGradient(0,-ry,0,ry);
      bodyGrad.addColorStop(0, '#ffffff');
      bodyGrad.addColorStop(0.3, '#ffd685');
      bodyGrad.addColorStop(1, '#2b2448');
      CTX.fillStyle = bodyGrad;
      CTX.beginPath();
      CTX.ellipse(0,0,rx,ry,0,0,Math.PI*2);
      CTX.fill();
      CTX.lineWidth = 2;
      CTX.strokeStyle = '#f5b432';
      CTX.stroke();
      const core = CTX.createRadialGradient(0,0,0,0,0,ry*0.7);
      core.addColorStop(0,'#fff7e2');
      core.addColorStop(1,'#ff6e7a');
      CTX.fillStyle = core;
      CTX.beginPath();
      CTX.ellipse(0,0,rx*0.45,ry*0.45,0,0,Math.PI*2);
      CTX.fill();
      CTX.fillStyle = '#0b1020';
      CTX.beginPath();
      CTX.arc(-rx*0.28, -ry*0.12, 6, 0, Math.PI*2);
      CTX.arc( rx*0.28, -ry*0.12, 6, 0, Math.PI*2);
      CTX.fill();
    }
    CTX.restore();

    // HP ë°”
    const barW = 260;
    const barH = 10;
    const ratio = Math.max(0, boss.hp / boss.maxHp);
    CTX.save();
    CTX.translate(G.w/2, 40);
    CTX.fillStyle = 'rgba(0,0,0,0.5)';
    CTX.fillRect(-barW/2, -barH/2, barW, barH);
    CTX.fillStyle = '#ff6e7a';
    CTX.fillRect(-barW/2, -barH/2, barW*ratio, barH);
    CTX.strokeStyle = '#e9edff';
    CTX.lineWidth = 1;
    CTX.strokeRect(-barW/2, -barH/2, barW, barH);
    CTX.restore();
  }

  function drawSupportItem(){
    if(!supportItem) return;
    const it = supportItem;
    CTX.save();
    CTX.translate(it.x, it.y);
    const tt = performance.now()/300;
    CTX.rotate(Math.sin(tt)*0.3);
    CTX.strokeStyle = C.supportItem;
    CTX.lineWidth = 2;
    CTX.beginPath();
    CTX.arc(0,0,it.r+4,0,Math.PI*2);
    CTX.stroke();
    const g = CTX.createRadialGradient(0,0,0,0,0,it.r);
    g.addColorStop(0,'#eafff3');
    g.addColorStop(0.5,C.supportItem);
    g.addColorStop(1,'rgba(0,0,0,0)');
    CTX.fillStyle = g;
    CTX.beginPath();
    CTX.arc(0,0,it.r,0,Math.PI*2);
    CTX.fill();
    CTX.restore();
  }

  // ===== Render =====
  function draw(){
    CTX.clearRect(0,0,G.w,G.h);

    CTX.save();
    // ì§€ì§„(ì¹´ë©”ë¼ í”ë“¤ë¦¼)
    if(shakeTime > 0){
      const f = shakeTime / 0.5; // 0.5ì´ˆ ê¸°ì¤€
      const mag = 6 * f;
      const ox = (Math.random()-0.5)*mag;
      const oy = (Math.random()-0.5)*mag;
      CTX.translate(ox, oy);
    }

    CTX.fillStyle=C.glow;
    CTX.fillRect(0,0,G.w,G.h);

    // ë³„
    for(let s of stars){
      CTX.fillStyle = (s.s>1.0)? C.star2 : C.star;
      CTX.globalAlpha = 0.4 + s.s*0.3;
      CTX.fillRect(s.x, s.y, 2, 2);
    }
    CTX.globalAlpha = 1;

    // ì§€ì› ì•„ì´í…œ
    drawSupportItem();

    // í”Œë ˆì´ì–´
    if(player && !S.over){
      drawPlayerShip();
    }

    // ì§€ì›ê¸°
    drawHelperShip();

    // í”Œë ˆì´ì–´ íƒ„
    for(const b of bullets){
      drawBullet(b);
    }

    // ì ë“¤
    for(const e of enemies){
      if(!e.alive) continue;
      drawEnemyShip(e);
    }

    // ë³´ìŠ¤
    drawBossShip();

    // ì  íƒ„
    for(const eb of enemyBullets){
      drawEnemyBullet(eb);
    }
    // ë³´ìŠ¤ íƒ„
    for(const bb of bossBullets){
      drawEnemyBullet(bb);
    }

    // í­ë°œ
    for(const ex of explosions){
      const a = 1 - ex.t/0.4;
      CTX.globalAlpha = Math.max(0,a);
      const g = CTX.createRadialGradient(ex.x,ex.y,0,ex.x,ex.y,20+ex.t*80);
      g.addColorStop(0,'#fff7cf');
      g.addColorStop(0.3,'#ffd685');
      g.addColorStop(1,'rgba(0,0,0,0)');
      CTX.fillStyle = g;
      CTX.beginPath();
      CTX.arc(ex.x,ex.y, 20+ex.t*80, 0, Math.PI*2);
      CTX.fill();
      CTX.globalAlpha = 1;
    }

    // í° ì ìˆ˜ íŒì—…
    for(const p of scorePops){
      const prog = p.t / p.dur;
      const y = p.y - prog*40;
      const alpha = 1 - prog;
      CTX.save();
      CTX.globalAlpha = alpha;
      CTX.fillStyle = '#ffe27a';
      CTX.font = 'bold 18px system-ui';
      const w = CTX.measureText(p.text).width;
      CTX.fillText(p.text, p.x - w/2, y);
      CTX.restore();
    }

    // ì›¨ì´ë¸Œ ë°°ë„ˆ
    if(waveBanner){
      const prog = waveBanner.t / waveBanner.dur;
      const alpha = 1 - prog;
      if(alpha > 0){
        CTX.save();
        CTX.globalAlpha = alpha;
        const scale = 1 + prog*0.2;
        CTX.translate(G.w/2, G.h*0.35);
        CTX.scale(scale, scale);
        CTX.fillStyle = '#e9edff';
        CTX.font = 'bold 40px system-ui';
        const txt = waveBanner.text;
        const w = CTX.measureText(txt).width;
        CTX.fillText(txt, -w/2, 0);
        CTX.restore();
      }
    }

    // ì˜¤ë²„ë ˆì´
    if(S.over){
      overlay('ê²Œì„ ì˜¤ë²„');
    } else if(!S.running){
      overlay('ì‹œì‘ / ì¬ì‹œì‘ ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”');
    } else if(S.paused){
      overlay('ì¼ì‹œì •ì§€ / Paused');
    }

    // ê¶ê·¹ê¸° í°ìƒ‰ í”Œë˜ì‹œ
    if(ultFlash){
      const p = ultFlash.t / ultFlash.dur;
      const alpha = (1 - p) * 0.95;
      if(alpha > 0){
        CTX.save();
        CTX.globalAlpha = alpha;
        CTX.fillStyle = '#ffffff';
        CTX.fillRect(0,0,G.w,G.h);
        CTX.restore();
      }
    }

    CTX.restore();
  }

  function overlay(txt){
    CTX.save();
    CTX.fillStyle='rgba(0,0,0,0.35)';
    CTX.fillRect(0,0,G.w,G.h);
    CTX.fillStyle='#e9edff';
    CTX.font='bold 28px system-ui';
    const w=CTX.measureText(txt).width;
    CTX.fillText(txt,(G.w-w)/2, G.h*0.45);
    CTX.restore();
  }

  // ===== Loop =====
  let lastTs=0;
  function loop(ts){
    requestAnimationFrame(loop);
    if(!S.running || S.paused){
      draw();
      return;
    }
    if(!lastTs) lastTs=ts;
    let dt = Math.min(0.03, (ts-lastTs)/1000);
    lastTs=ts;
    const t = ts/1000;
    step(dt,t);
    draw();
  }

  // ===== Boot =====
  fit();
  updateHUD();
  draw();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
