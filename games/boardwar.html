<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>ë•…ë”°ë¨¹ê¸°</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
  <style>
    * { box-sizing: border-box; }
    html, body { margin: 0; padding: 0; overscroll-behavior: none; }
    body {
      min-height: 100vh;
      display: flex;
      align-items: flex-start;
      justify-content: center;
      background: radial-gradient(circle at top, #1f2937 0, #020617 55%, #000 100%);
      color: #e5e7eb;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      touch-action: none;
    }
    .wrap {
      max-width: 960px;
      width: 100%;
      padding: 16px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
    }
    h1 { margin: 0; font-size: 22px; letter-spacing: 0.04em; }

    .hud {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
      justify-content: center;
      font-size: 14px;
    }
    .badge {
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.85);
      border: 1px solid rgba(148, 163, 184, 0.5);
      backdrop-filter: blur(8px);
    }

    .game-shell { position: relative; display: inline-block; }
    canvas {
      background: #020617;
      border-radius: 12px;
      border: 2px solid #4b5563;
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.6);
      image-rendering: pixelated;
      max-width: 100%;
      display: block;
    }

    .overlay, .start-layer {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .overlay { display: none; pointer-events: none; }
    .overlay-inner {
      pointer-events: auto;
      padding: 16px 24px;
      border-radius: 16px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(148, 163, 184, 0.7);
      text-align: center;
      min-width: 240px;
    }
    .overlay-title { font-size: 20px; margin-bottom: 4px; }
    .overlay-sub {
      font-size: 13px;
      color: #9ca3af;
      margin-bottom: 10px;
      white-space: pre-line;
    }
    .overlay-inner button {
      margin-top: 4px;
      padding: 6px 14px;
      border-radius: 999px;
      border: none;
      background: #22c55e;
      color: #022c22;
      font-weight: 600;
      cursor: pointer;
    }

    .start-layer { pointer-events: none; }
    .start-inner {
      pointer-events: auto;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: center;
      padding: 10px 14px;
      border-radius: 999px;
      background: rgba(15,23,42,0.95);
      border: 1px solid rgba(55,65,81,0.8);
    }
    #nicknameInput {
      padding: 8px 14px;
      border-radius: 999px;
      border: 1px solid #4b5563;
      background: #020617;
      color: #e5e7eb;
      font-size: 13px;
      min-width: 140px;
      outline: none;
    }
    #nicknameInput::placeholder { color: #6b7280; }

    #startButton, #localRankButton {
      padding: 8px 14px;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      box-shadow: 0 8px 16px rgba(15, 23, 42, 0.6);
      white-space: nowrap;
    }
    #startButton { background: #22c55e; color: #022c22; }
    #startButton:hover { filter: brightness(1.05); }
    #localRankButton { background: #0ea5e9; color: #0f172a; }
    #localRankButton:hover { filter: brightness(1.05); }

    .joystick {
      margin-top: 10px;
      display: flex;
      justify-content: center;
      touch-action: none;
    }
    .stick-base {
      width: 160px;
      height: 160px;
      border-radius: 999px;
      background: radial-gradient(circle at top, #111827, #020617);
      border: 2px solid #4b5563;
      position: relative;
      box-shadow: 0 10px 25px rgba(0,0,0,0.6);
      touch-action: none;
    }
    .stick-handle {
      width: 80px;
      height: 80px;
      border-radius: 999px;
      background: radial-gradient(circle at top, #0f172a, #020617);
      border: 2px solid #9ca3af;
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 6px 18px rgba(15,23,42,0.8);
      touch-action: none;
    }

    .item-legend {
      margin-top: 10px;
      padding: 8px 10px;
      border-radius: 10px;
      background: rgba(15,23,42,0.85);
      border: 1px solid rgba(55,65,81,0.8);
      font-size: 12px;
      max-width: 640px;
    }
    .legend-item { display: flex; align-items: center; gap: 8px; margin-bottom: 4px; }
    .legend-item:last-child { margin-bottom: 0; }
    .legend-icon {
      width: 22px;
      height: 22px;
      border-radius: 999px;
      background: #020617;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
    }

    .hint {
      font-size: 13px;
      color: #9ca3af;
      text-align: center;
      max-width: 640px;
    }
    .hint kbd {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 4px;
      border: 1px solid #6b7280;
      font-size: 11px;
      background: rgba(15, 23, 42, 0.9);
    }

    #restartBtn {
      margin-top: 4px;
      padding: 8px 16px;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      font-size: 14px;
      background: #22c55e;
      color: #022c22;
      font-weight: 600;
      box-shadow: 0 10px 25px rgba(34, 197, 94, 0.4);
      display: none;
    }
    #restartBtn:hover {
      filter: brightness(1.05);
      transform: translateY(-1px);
    }
    #restartBtn:active {
      transform: translateY(0);
      box-shadow: 0 6px 18px rgba(34, 197, 94, 0.35);
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>ë•…ë”°ë¬µê¸°</h1>

    <div class="hud">
      <div class="badge">ìŠ¤í…Œì´ì§€: <span id="stage">1</span></div>
      <div class="badge">ì ìˆ˜: <span id="score">0</span></div>
      <div class="badge">ì±„ìš´ ë•…: <span id="fill">0</span>%</div>
      <div class="badge">ëª©í‘œ: <span id="target">90</span>%</div>
      <div class="badge">ëª©ìˆ¨: <span id="lives">3</span></div>
    </div>

    <div class="game-shell">
      <canvas id="game" width="640" height="640"></canvas>

      <div class="overlay" id="overlay">
        <div class="overlay-inner">
          <div class="overlay-title" id="overlayTitle">ê²Œì„ ì¢…ë£Œ</div>
          <div class="overlay-sub" id="overlaySub"></div>
          <button id="overlayRestart">í™•ì¸</button>
        </div>
      </div>

      <div class="start-layer" id="startLayer">
        <div class="start-inner">
          <input id="nicknameInput" maxlength="12" placeholder="ë‹‰ë„¤ì„ ì…ë ¥" />
          <button id="startButton">ê²Œì„ ì‹œì‘</button>
          <button id="localRankButton">ë¡œì»¬ ë“±ìˆ˜</button>
        </div>
      </div>
    </div>

    <div class="joystick" id="joystickArea">
      <div class="stick-base">
        <div class="stick-handle" id="stickHandle"></div>
      </div>
    </div>

    <div class="item-legend">
      <div class="legend-item">
        <span class="legend-icon">âš¡</span>
        <span class="legend-text">ì†ë„ ë²„í”„: 30ì´ˆ ë™ì•ˆ ê²Œì„ ì†ë„ +10%</span>
      </div>
      <div class="legend-item">
        <span class="legend-icon">â¤</span>
        <span class="legend-text">ëª©ìˆ¨ +1: í˜„ì¬ ë‚¨ì€ ëª©ìˆ¨ì´ 1 ì¦ê°€</span>
      </div>
      <div class="legend-item">
        <span class="legend-icon">!</span>
        <span class="legend-text">ìœ„í—˜: 1ì (ë¹¨ê°„ ì›í˜• ì ) 1ë§ˆë¦¬ê°€ ì¶”ê°€ ë“±ì¥</span>
      </div>
    </div>

    <div class="hint">
      <p>
        <kbd>â†‘</kbd> <kbd>â†“</kbd> <kbd>â†</kbd> <kbd>â†’</kbd> ë˜ëŠ” <kbd>W</kbd> <kbd>A</kbd> <kbd>S</kbd> <kbd>D</kbd> ë¡œ ì´ë™í•˜ê³ ,<br />
        í™”ë©´ì˜ 90%ë¥¼ ì±„ìš°ë©´ ë‹¤ìŒ ìŠ¤í…Œì´ì§€ë¡œ ì§„í–‰í•´.<br />
        ìŠ¤í…Œì´ì§€ 1~3ì„ ëª¨ë‘ í´ë¦¬ì–´í•˜ë©´ ì§„ì§œ ë³´ìƒ(?)ì´ ê¸°ë‹¤ë¦¬ê³  ìˆì–´.
      </p>
    </div>

    <button id="restartBtn">ì²˜ìŒë¶€í„° ë‹¤ì‹œ</button>
  </div>

  <script>
    (function () {
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");

      const CONFIG = {
        COLS: 80,
        ROWS: 80,
        MIN_SPEED: 4,
        MAX_SPEED: 5,
        SPEED_TYPE2: 2,
        TARGET_PERCENT: 90,
        MAX_LIVES: 3,
        BUFF_DURATION: 30000,
        SPEED_BUFF_FACTOR: 1.1,
        MOVE_INTERVAL: 16,
        PLAYER_SPEED: 0.8
      };

      const STAGE_INFO = {
        1: {
          couponTitle: "ìŠ¤íƒ€ë²…ìŠ¤ ì¹´ë¼ë©œë§ˆí‚¤ì•„ë˜ [Tall]",
          couponDesc: "ëª¨ë°”ì¼ ê¸°í”„í‹°ì½˜ â€“ ì¹´ë¼ë©œë§ˆí‚¤ì•„ë˜ Tall 1ì”",
          clearSuffix: "(ìŠ¤íƒ€ë²…ìŠ¤ ì•„ë©”ë¦¬ì¹´ë…¸ 1ì” ê¸°í”„í‹°ì½˜)"
        },
        2: {
          couponTitle: "ìŠ¤íƒ€ë²…ìŠ¤ ì•„ë©”ë¦¬ì¹´ë…¸ + ë””ì €íŠ¸ ì„¸íŠ¸",
          couponDesc: "ì•„ë©”ë¦¬ì¹´ë…¸ 1ì” + ë””ì €íŠ¸ 1ì¢… ì„¸íŠ¸",
          clearSuffix: "(ìŠ¤íƒ€ë²…ìŠ¤ ì•„ë©”ë¦¬ì¹´ë…¸ + ë””ì €íŠ¸ ì„¸íŠ¸ ê¸°í”„í‹°ì½˜)"
        },
        3: {
          couponTitle: "ì œì‘ì ë°¥ ì‚¬ì£¼ëŠ” ì¿ í°",
          couponDesc: "ì œì‘ìê°€ ì§ì ‘ ì‚¬ì£¼ëŠ” ì‹ì‚¬ í•œ ë¼",
          clearSuffix: null
        }
      };

      // ìŠ¤í…Œì´ì§€ë³„ ì /ì•„ì´í…œ ì„¤ì •
      const STAGE_CONFIG = {
        1: { enemies: { type1: 2, type2: 0 }, itemCount: 2 },
        2: { enemies: { type1: 3, type2: 1 }, itemCount: 2 },
        3: { enemies: { type1: 4, type2: 2 }, itemCount: 2 }
      };

      const cellSize = canvas.width / CONFIG.COLS;

      // DOM
      const stageEl = document.getElementById("stage");
      const scoreEl = document.getElementById("score");
      const fillEl = document.getElementById("fill");
      const targetEl = document.getElementById("target");
      const livesEl = document.getElementById("lives");
      const restartBtn = document.getElementById("restartBtn");
      const overlay = document.getElementById("overlay");
      const overlayTitle = document.getElementById("overlayTitle");
      const overlaySub = document.getElementById("overlaySub");
      const overlayRestart = document.getElementById("overlayRestart");
      const startLayer = document.getElementById("startLayer");
      const startButton = document.getElementById("startButton");
      const localRankButton = document.getElementById("localRankButton");
      const nicknameInput = document.getElementById("nicknameInput");
      const joystickArea = document.getElementById("joystickArea");
      const joystickHandle = document.getElementById("stickHandle");

      targetEl.textContent = CONFIG.TARGET_PERCENT;

      // ì¿ í° ë°°ê²½ í”„ë¦¬ë Œë”
      let couponCanvas = null;
      let couponCtx = null;
      let lastCouponStage = null;

      // ê²Œì„ ìƒíƒœ
      let board;
      let player;
      let enemies = [];
      let items = [];
      let lastTime = 0;
      let moveTimer = 0;
      let lastHasInput = false;
      let playerMoveAccum = 0;

      let score = 0;
      let lives = CONFIG.MAX_LIVES;
      let stage = 1;
      let running = false;
      let pendingAction = null;
      let speedBuffRemaining = 0;

      const keys = { left: false, right: false, up: false, down: false };

      // ===== ì…ë ¥ ì²˜ë¦¬ =====
      function setDirFlag(dir, pressed) {
        keys[dir] = pressed;
      }

      function getInputDir() {
        let dx = 0, dy = 0;
        if (keys.left && !keys.right) dx = -1;
        else if (keys.right && !keys.left) dx = 1;
        if (keys.up && !keys.down) dy = -1;
        else if (keys.down && !keys.up) dy = 1;
        return { x: dx, y: dy };
      }

      document.addEventListener("keydown", function (e) {
        if (e.key === " " && !running && startLayer.style.display !== "none") {
          e.preventDefault();
          beginPlayIfReady();
          return;
        }
        if (e.key === "ArrowLeft" || e.key === "a") { e.preventDefault(); setDirFlag("left", true); }
        if (e.key === "ArrowRight" || e.key === "d") { e.preventDefault(); setDirFlag("right", true); }
        if (e.key === "ArrowUp" || e.key === "w") { e.preventDefault(); setDirFlag("up", true); }
        if (e.key === "ArrowDown" || e.key === "s") { e.preventDefault(); setDirFlag("down", true); }
      });

      document.addEventListener("keyup", function (e) {
        if (e.key === "ArrowLeft" || e.key === "a") { e.preventDefault(); setDirFlag("left", false); }
        if (e.key === "ArrowRight" || e.key === "d") { e.preventDefault(); setDirFlag("right", false); }
        if (e.key === "ArrowUp" || e.key === "w") { e.preventDefault(); setDirFlag("up", false); }
        if (e.key === "ArrowDown" || e.key === "s") { e.preventDefault(); setDirFlag("down", false); }
      });

      startButton.addEventListener("click", beginPlayIfReady);
      restartBtn.addEventListener("click", startNewGame);
      overlayRestart.addEventListener("click", handleOverlayConfirm);
      localRankButton.addEventListener("click", showLocalRank);

      // ëª¨ë°”ì¼ ì¡°ì´ìŠ¤í‹±
      function bindJoystick() {
        if (!joystickArea || !joystickHandle) return;
        const base = joystickArea.querySelector(".stick-base");
        if (!base) return;

        let active = false;

        function resetStick() {
          joystickHandle.style.left = "50%";
          joystickHandle.style.top = "50%";
          keys.up = keys.down = keys.left = keys.right = false;
        }

        function getPoint(e) {
          if (e.touches && e.touches.length > 0) {
            return { x: e.touches[0].clientX, y: e.touches[0].clientY };
          }
          return { x: e.clientX, y: e.clientY };
        }

        function updateFromPoint(clientX, clientY) {
          const rect = base.getBoundingClientRect();
          const centerX = rect.left + rect.width / 2;
          const centerY = rect.top + rect.height / 2;
          let dx = clientX - centerX;
          let dy = clientY - centerY;
          const maxR = rect.width / 2;
          const len = Math.hypot(dx, dy);

          if (len < maxR * 0.2) {
            resetStick();
            return;
          }

          const clampedLen = Math.min(len, maxR * 0.9);
          const nx = dx / (len || 1);
          const ny = dy / (len || 1);
          const px = centerX + nx * clampedLen;
          const py = centerY + ny * clampedLen;

          joystickHandle.style.left = ((px - rect.left) / rect.width * 100) + "%";
          joystickHandle.style.top = ((py - rect.top) / rect.height * 100) + "%";

          let angle = Math.atan2(ny, nx);
          let deg = angle * 180 / Math.PI;
          if (deg < 0) deg += 360;

          keys.up = keys.down = keys.left = keys.right = false;

          if (deg >= 337.5 || deg < 22.5) keys.right = true;
          else if (deg < 67.5) { keys.right = true; keys.down = true; }
          else if (deg < 112.5) keys.down = true;
          else if (deg < 157.5) { keys.down = true; keys.left = true; }
          else if (deg < 202.5) keys.left = true;
          else if (deg < 247.5) { keys.left = true; keys.up = true; }
          else if (deg < 292.5) keys.up = true;
          else { keys.up = true; keys.right = true; }
        }

        base.addEventListener("mousedown", (e) => {
          e.preventDefault();
          active = true;
          const p = getPoint(e);
          updateFromPoint(p.x, p.y);
        });
        base.addEventListener("touchstart", (e) => {
          e.preventDefault();
          active = true;
          const p = getPoint(e);
          updateFromPoint(p.x, p.y);
        }, { passive: false });

        function move(e) {
          if (!active) return;
          e.preventDefault();
          const p = getPoint(e);
          updateFromPoint(p.x, p.y);
        }

        function end(e) {
          if (!active) return;
          e.preventDefault();
          active = false;
          resetStick();
        }

        window.addEventListener("mousemove", move);
        window.addEventListener("touchmove", move, { passive: false });
        window.addEventListener("mouseup", end);
        window.addEventListener("touchend", end, { passive: false });
        window.addEventListener("touchcancel", end, { passive: false });

        resetStick();
      }

      // ===== ë³´ë“œ/í”Œë ˆì´ì–´ ì´ˆê¸°í™” =====
      function createEmptyBoard() {
        const b = [];
        for (let y = 0; y < CONFIG.ROWS; y++) {
          const row = [];
          for (let x = 0; x < CONFIG.COLS; x++) {
            if (y === 0 || y === CONFIG.ROWS - 1 || x === 0 || x === CONFIG.COLS - 1) row.push(1);
            else row.push(0);
          }
          b.push(row);
        }
        return b;
      }

      function resetPlayer() {
        player = { x: 1, y: 0, drawing: false, trail: [] };
        playerMoveAccum = 0;
        keys.left = keys.right = keys.up = keys.down = false;
      }

      function randomSpeedBetween() {
        const { MIN_SPEED, MAX_SPEED } = CONFIG;
        return MIN_SPEED + Math.random() * (MAX_SPEED - MIN_SPEED);
      }

      function shuffleArray(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
      }

      // ===== ì /ì•„ì´í…œ ìŠ¤í° =====
      function spawnEnemyType(type, count) {
        const baseR1 = cellSize * 2.2;
        const baseR2 = baseR1 * 2.5;
        for (let i = 0; i < count; i++) {
          const ex = 2 + Math.floor(Math.random() * (CONFIG.COLS - 4));
          const ey = 2 + Math.floor(Math.random() * (CONFIG.ROWS - 4));
          const angle = Math.random() * Math.PI * 2;
          const speed = type === 2 ? CONFIG.SPEED_TYPE2 : randomSpeedBetween();
          enemies.push({
            type,
            radius: type === 2 ? baseR2 : baseR1,
            x: ex * cellSize + cellSize / 2,
            y: ey * cellSize + cellSize / 2,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed
          });
        }
      }

      function spawnEnemiesForStage(stageNum) {
        enemies = [];
        const cfg = STAGE_CONFIG[stageNum]?.enemies || STAGE_CONFIG[1].enemies;
        if (cfg.type1) spawnEnemyType(1, cfg.type1);
        if (cfg.type2) spawnEnemyType(2, cfg.type2);
      }

      function placeRandomItem(type) {
        for (let tries = 0; tries < 100; tries++) {
          const rx = 2 + Math.floor(Math.random() * (CONFIG.COLS - 4));
          const ry = 2 + Math.floor(Math.random() * (CONFIG.ROWS - 4));
          if (board[ry][rx] !== 0) continue;
          if (items.some(it => it.x === rx && it.y === ry)) continue;
          items.push({ x: rx, y: ry, type });
          break;
        }
      }

      function spawnItemsForStage(stageNum) {
        items = [];
        const types = ["speed", "life", "enemy"];
        shuffleArray(types);
        const count = STAGE_CONFIG[stageNum]?.itemCount ?? 2;
        for (let i = 0; i < count; i++) placeRandomItem(types[i]);
      }

      function spawnExtraEnemy() {
        const baseR1 = cellSize * 2.2;
        for (let tries = 0; tries < 100; tries++) {
          const ex = 2 + Math.floor(Math.random() * (CONFIG.COLS - 4));
          const ey = 2 + Math.floor(Math.random() * (CONFIG.ROWS - 4));
          if (board[ey][ex] === 1) continue;
          const speed = randomSpeedBetween();
          const angle = Math.random() * Math.PI * 2;
          enemies.push({
            type: 1,
            radius: baseR1,
            x: ex * cellSize + cellSize / 2,
            y: ey * cellSize + cellSize / 2,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed
          });
          break;
        }
      }

      // ===== ì•„ì´í…œ íš¨ê³¼ / ê·¸ë¦¬ê¸° ë§¤í•‘ =====
      const ITEM_EFFECTS = {
        speed() { speedBuffRemaining = CONFIG.BUFF_DURATION; },
        life() {
          lives = Math.min(CONFIG.MAX_LIVES, lives + 1);
          updateHUD(getFillPercent());
        },
        enemy() { spawnExtraEnemy(); }
      };

      const ITEM_DRAWERS = {
        speed(cx, cy, r) {
          ctx.save();
          ctx.translate(cx, cy);
          ctx.beginPath();
          ctx.moveTo(-r * 0.2, -r * 0.8);
          ctx.lineTo(r * 0.1, -r * 0.1);
          ctx.lineTo(-r * 0.1, -r * 0.1);
          ctx.lineTo(r * 0.2, r * 0.8);
          ctx.lineTo(-r * 0.1, r * 0.2);
          ctx.lineTo(0, r * 0.2);
          ctx.closePath();
          ctx.fillStyle = "#facc15";
          ctx.fill();
          ctx.lineWidth = 2;
          ctx.strokeStyle = "#fef9c3";
          ctx.stroke();
          ctx.restore();
        },
        life(cx, cy, rItem) {
          ctx.save();
          ctx.translate(cx, cy);
          ctx.beginPath();
          const r = rItem * 0.7;
          ctx.moveTo(0, r);
          ctx.bezierCurveTo(-r, r * 0.4, -r, -r * 0.2, 0, -r * 0.4);
          ctx.bezierCurveTo(r, -r * 0.2, r, r * 0.4, 0, r);
          ctx.fillStyle = "#22c55e";
          ctx.fill();
          ctx.lineWidth = 2;
          ctx.strokeStyle = "#bbf7d0";
          ctx.stroke();
          ctx.restore();
        },
        enemy(cx, cy, rItem) {
          ctx.save();
          ctx.translate(cx, cy);
          ctx.beginPath();
          ctx.moveTo(0, -rItem * 0.8);
          ctx.lineTo(rItem * 0.8, rItem * 0.8);
          ctx.lineTo(-rItem * 0.8, rItem * 0.8);
          ctx.closePath();
          ctx.fillStyle = "#f97316";
          ctx.fill();
          ctx.lineWidth = 2;
          ctx.strokeStyle = "#ffedd5";
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(0, -rItem * 0.2);
          ctx.lineTo(0, rItem * 0.3);
          ctx.lineWidth = 3;
          ctx.strokeStyle = "#1f2937";
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(0, rItem * 0.5, rItem * 0.08, 0, Math.PI * 2);
          ctx.fillStyle = "#1f2937";
          ctx.fill();
          ctx.restore();
        }
      };

      function applyItem(type) {
        ITEM_EFFECTS[type] && ITEM_EFFECTS[type]();
      }

      // ===== HUD / ì‹œì‘/ì˜¤ë²„ë ˆì´ =====
      function updateHUD(fillPercent) {
        stageEl.textContent = stage;
        scoreEl.textContent = score;
        fillEl.textContent = fillPercent.toFixed(0);
        livesEl.textContent = lives;
      }

      function beginPlayIfReady() {
        if (!running) {
          running = true;
          startLayer.style.display = "none";
        }
      }

      function startNewGame() {
        stage = 1;
        stageEl.textContent = stage;
        overlay.style.display = "none";
        restartBtn.style.display = "none";
        startLayer.style.display = "flex";
        running = false;
        pendingAction = null;
        setupStage(stage, true);
      }

      function showOverlay(title, sub, action) {
        overlayTitle.textContent = title;
        overlaySub.textContent = sub || "";
        overlay.style.display = "flex";
        pendingAction = action || null;
      }

      function handleOverlayConfirm() {
        overlay.style.display = "none";
        if (pendingAction === "stage2") {
          stage = 2;
          setupStage(stage, false);
          running = true;
        } else if (pendingAction === "stage3") {
          stage = 3;
          setupStage(stage, false);
          running = true;
        } else if (pendingAction === "restart") {
          startNewGame();
        }
        pendingAction = null;
      }

      function getNickname() {
        if (!nicknameInput) return "í”Œë ˆì´ì–´";
        const name = nicknameInput.value.trim();
        return name || "í”Œë ˆì´ì–´";
      }

      function saveScoreIfNeeded() {
        if (score <= 0 || !window.localStorage) return;
        let arr;
        try {
          arr = JSON.parse(localStorage.getItem("qixGiftLocalScores") || "[]");
        } catch {
          arr = [];
        }
        arr.push({ name: getNickname(), score, stage, time: new Date().toISOString() });
        arr.sort((a, b) => b.score - a.score);
        if (arr.length > 30) arr = arr.slice(0, 30);
        localStorage.setItem("qixGiftLocalScores", JSON.stringify(arr));
      }

      function showLocalRank() {
        if (!window.localStorage) {
          alert("ì´ ë¸Œë¼ìš°ì €ì—ì„œëŠ” ë¡œì»¬ ë“±ìˆ˜ë¥¼ ì €ì¥í•  ìˆ˜ ì—†ì–´.");
          return;
        }
        let arr;
        try {
          arr = JSON.parse(localStorage.getItem("qixGiftLocalScores") || "[]");
        } catch {
          arr = [];
        }
        if (!arr.length) {
          alert("ì•„ì§ ì €ì¥ëœ ê¸°ë¡ì´ ì—†ì–´.");
          return;
        }
        const lines = arr.slice(0, 10).map((entry, idx) => {
          const dateStr = entry.time ? entry.time.slice(0, 10) : "";
          return (
            (idx + 1) + "ìœ„ - " +
            (entry.name || "í”Œë ˆì´ì–´") + " : " +
            entry.score + "ì  (ìµœì¢… ìŠ¤í…Œì´ì§€ " +
            entry.stage + ", " + dateStr + ")"
          );
        });
        alert(lines.join("\n"));
      }

      // ===== ì¶©ëŒ / ì´ë™ =====
      function blockedPixel(px, py, radius) {
        const steps = 18;
        for (let i = 0; i < steps; i++) {
          const ang = (Math.PI * 2 * i) / steps;
          const sx = px + Math.cos(ang) * radius;
          const sy = py + Math.sin(ang) * radius;
          const cx = Math.floor(sx / cellSize);
          const cy = Math.floor(sy / cellSize);
          if (cx < 0 || cx >= CONFIG.COLS || cy < 0 || cy >= CONFIG.ROWS) return true;
          if (board[cy][cx] === 1) return true;
        }
        return false;
      }

      function randomBounceTowardPlayer(enemy) {
        const px = (player.x + 0.5) * cellSize;
        const py = (player.y + 0.5) * cellSize;
        let dx = px - enemy.x;
        let dy = py - enemy.y;
        let len = Math.hypot(dx, dy);
        if (!len) { dx = 1; dy = 0; len = 1; }
        dx /= len; dy /= len;
        const baseAngle = Math.atan2(dy, dx);
        const maxAngle = Math.PI / 3;
        const offset = (Math.random() * 2 - 1) * maxAngle;
        const angle = baseAngle + offset;
        const speed = (enemy.type === 2) ? CONFIG.SPEED_TYPE2 : randomSpeedBetween();
        return { vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed };
      }

      function clearTrail() {
        for (let y = 0; y < CONFIG.ROWS; y++) {
          for (let x = 0; x < CONFIG.COLS; x++) {
            if (board[y][x] === 2) board[y][x] = 0;
          }
        }
      }

      // ğŸ”§ ì  ë¦¬ì…‹ ê¸ˆì§€: ì£½ì€ ì ì€ ë¶€í™œí•˜ì§€ ì•ŠìŒ
      function loseLife() {
        clearTrail();
        player.drawing = false;
        player.trail = [];
        lives -= 1;

        if (lives <= 0) {
          lives = 0;
          running = false;
          updateHUD(getFillPercent());
          saveScoreIfNeeded();
          restartBtn.style.display = "inline-block";
          showOverlay("ê²Œì„ ì˜¤ë²„", "ì ì´ë‚˜ ì„ ì— ë‹¿ì•˜ì–´â€¦ ë‹¤ì‹œ í•œ íŒ?", "restart");
        } else {
          // í”Œë ˆì´ì–´ë§Œ ë¦¬ì…‹, ì (enemies)ì€ ê·¸ëŒ€ë¡œ ìœ ì§€
          resetPlayer();
          updateHUD(getFillPercent());
        }
      }

      function stepPlayer() {
        const dir = getInputDir();
        const dx = dir.x, dy = dir.y;
        if (dx === 0 && dy === 0) return;

        playerMoveAccum += CONFIG.PLAYER_SPEED;
        if (playerMoveAccum < 1) return;
        playerMoveAccum -= 1;

        const nx = player.x + dx;
        const ny = player.y + dy;
        if (nx < 0 || nx >= CONFIG.COLS || ny < 0 || ny >= CONFIG.ROWS) return;

        const nextCell = board[ny][nx];

        if (!player.drawing) {
          if (nextCell === 1) {
            player.x = nx; player.y = ny;
          } else if (nextCell === 0) {
            player.drawing = true;
            player.x = nx; player.y = ny;
            player.trail = [{ x: nx, y: ny }];
            board[ny][nx] = 2;
          }
        } else {
          if (nextCell === 0) {
            player.x = nx; player.y = ny;
            player.trail.push({ x: nx, y: ny });
            board[ny][nx] = 2;
          } else if (nextCell === 1) {
            player.x = nx; player.y = ny;
            completeTrailAndFill();
          } else if (nextCell === 2) {
            loseLife();
          }
        }
      }

      function stepEnemies() {
        for (const enemy of enemies) {
          let nx = enemy.x + enemy.vx;
          let ny = enemy.y + enemy.vy;

          if (blockedPixel(nx, ny, enemy.radius)) {
            let tries = 0;
            let bounced = false;
            while (tries < 8) {
              const nd = randomBounceTowardPlayer(enemy);
              enemy.vx = nd.vx; enemy.vy = nd.vy;
              nx = enemy.x + enemy.vx;
              ny = enemy.y + enemy.vy;
              if (!blockedPixel(nx, ny, enemy.radius)) {
                bounced = true;
                break;
              }
              tries++;
            }
            if (!bounced) {
              enemy.vx = -enemy.vx;
              enemy.vy = -enemy.vy;
              nx = enemy.x + enemy.vx;
              ny = enemy.y + enemy.vy;
            }
          }

          enemy.x = nx; enemy.y = ny;

          // í™”ë©´ ê²½ê³„
          if (enemy.x < cellSize) enemy.x = cellSize;
          if (enemy.x > canvas.width - cellSize) enemy.x = canvas.width - cellSize;
          if (enemy.y < cellSize) enemy.y = cellSize;
          if (enemy.y > canvas.height - cellSize) enemy.y = canvas.height - cellSize;

          // ë¨¹ì€ ë•… ì•ˆì— ë¼ëŠ” ê²ƒ ë°©ì§€
          if (blockedPixel(enemy.x, enemy.y, enemy.radius)) {
            for (let t = 0; t < 40; t++) {
              const ex = 2 + Math.floor(Math.random() * (CONFIG.COLS - 4));
              const ey = 2 + Math.floor(Math.random() * (CONFIG.ROWS - 4));
              const rx = ex * cellSize + cellSize / 2;
              const ry = ey * cellSize + cellSize / 2;
              if (!blockedPixel(rx, ry, enemy.radius)) {
                enemy.x = rx; enemy.y = ry;
                break;
              }
            }
          }
        }

        // ì ë¼ë¦¬ ì„œë¡œ ë°€ì³ë‚´ê¸°
        for (let i = 0; i < enemies.length; i++) {
          for (let j = i + 1; j < enemies.length; j++) {
            const a = enemies[i], b = enemies[j];
            const dx = b.x - a.x;
            const dy = b.y - a.y;
            const dist = Math.hypot(dx, dy);
            const minDist = (a.radius + b.radius) * 0.9;
            if (dist > 0 && dist < minDist) {
              const tvx = a.vx, tvy = a.vy;
              a.vx = b.vx; a.vy = b.vy;
              b.vx = tvx; b.vy = tvy;

              const overlap = (minDist - dist) / 2;
              const nx = dx / dist;
              const ny = dy / dist;
              a.x -= nx * overlap;
              a.y -= ny * overlap;
              b.x += nx * overlap;
              b.y += ny * overlap;
            }
          }
        }
      }

      function checkCollisions() {
        const playerRadius = cellSize * 0.9;
        const pcx = (player.x + 0.5) * cellSize;
        const pcy = (player.y + 0.5) * cellSize;

        // í”Œë ˆì´ì–´ê°€ í˜„ì¬ ì„œ ìˆëŠ” ì¹¸ì´ ë²½/ì±„ìš´ ë•…(1)ì¸ì§€ ì—¬ë¶€
        const onLand = board[player.y]?.[player.x] === 1;

        for (const enemy of enemies) {
          // 1) í”Œë ˆì´ì–´ ì§ì ‘ ì¶©ëŒ: ë°”ë‹¤(0)ë‚˜ ì„ (2)ì— ìˆì„ ë•Œë§Œ ì²´í¬
          if (!onLand) {
            const dx = enemy.x - pcx;
            const dy = enemy.y - pcy;
            const dist = Math.hypot(dx, dy);
            if (dist < enemy.radius + playerRadius * 0.8) {
              loseLife();
              return;
            }
          }

          // 2) ì„ (2)ì™€ì˜ ì¶©ëŒì€ í•­ìƒ ì²´í¬
          const steps = 24;
          for (let i = 0; i < steps; i++) {
            const ang = (Math.PI * 2 * i) / steps;
            const sx = enemy.x + Math.cos(ang) * enemy.radius;
            const sy = enemy.y + Math.sin(ang) * enemy.radius;
            const cx = Math.floor(sx / cellSize);
            const cy = Math.floor(sy / cellSize);
            if (cx < 0 || cx >= CONFIG.COLS || cy < 0 || cy >= CONFIG.ROWS) continue;
            if (board[cy][cx] === 2) {
              loseLife();
              return;
            }
          }
        }
      }

      // ===== ì˜ì—­ ì±„ìš°ê¸° =====
      function getFillPercent() {
        let filled = 0;
        let total = 0;
        for (let y = 1; y < CONFIG.ROWS - 1; y++) {
          for (let x = 1; x < CONFIG.COLS - 1; x++) {
            total++;
            if (board[y][x] === 1) filled++;
          }
        }
        if (total === 0) return 0;
        return (filled / total) * 100;
      }

      // ğŸ”‘ í•µì‹¬: ì  ë¶„í¬ì— ë”°ë¼ ì–´ëŠ ì˜ì—­ì„ ì±„ìš¸ì§€ ê²°ì •
      function completeTrailAndFill() {
        // 1) ì„ (2)ì„ ë•…(1)ìœ¼ë¡œ ë³€ê²½
        for (let y = 0; y < CONFIG.ROWS; y++) {
          for (let x = 0; x < CONFIG.COLS; x++) {
            if (board[y][x] === 2) board[y][x] = 1;
          }
        }
        player.drawing = false;
        player.trail = [];

        // 2) ë°”ë‹¤(0) ì˜ì—­ ì»´í¬ë„ŒíŠ¸ ì°¾ê¸°
        const compIndex = [];
        for (let y = 0; y < CONFIG.ROWS; y++) {
          compIndex.push(new Array(CONFIG.COLS).fill(-1));
        }
        const compSizes = [];
        let compCount = 0;
        const dirs = [
          { x: 1, y: 0 }, { x: -1, y: 0 },
          { x: 0, y: 1 }, { x: 0, y: -1 }
        ];

        for (let y = 0; y < CONFIG.ROWS; y++) {
          for (let x = 0; x < CONFIG.COLS; x++) {
            if (board[y][x] !== 0 || compIndex[y][x] !== -1) continue;
            const q = [{ x, y }];
            compIndex[y][x] = compCount;
            let size = 0;
            while (q.length) {
              const cur = q.shift();
              size++;
              for (const d of dirs) {
                const nx = cur.x + d.x;
                const ny = cur.y + d.y;
                if (nx < 0 || nx >= CONFIG.COLS || ny < 0 || ny >= CONFIG.ROWS) continue;
                if (board[ny][nx] !== 0) continue;
                if (compIndex[ny][nx] !== -1) continue;
                compIndex[ny][nx] = compCount;
                q.push({ x: nx, y: ny });
              }
            }
            compSizes.push(size);
            compCount++;
          }
        }

        let newlyClaimed = 0;

        if (compCount > 0) {
          // 3) ê° ì»´í¬ë„ŒíŠ¸ë§ˆë‹¤ ì ì´ ëª‡ ë§ˆë¦¬ ë“¤ì–´ìˆëŠ”ì§€ ê³„ì‚°
          const compEnemies = new Array(compCount).fill(0);
          const enemyCompIds = new Array(enemies.length).fill(-1);

          for (let ei = 0; ei < enemies.length; ei++) {
            const enemy = enemies[ei];
            const cx = Math.floor(enemy.x / cellSize);
            const cy = Math.floor(enemy.y / cellSize);
            if (cx < 0 || cx >= CONFIG.COLS || cy < 0 || cy >= CONFIG.ROWS) continue;
            const cid = compIndex[cy][cx];
            if (cid !== -1) {
              enemyCompIds[ei] = cid;
              compEnemies[cid]++;
            }
          }

          let compsWithEnemies = 0;
          for (let i = 0; i < compCount; i++) {
            if (compEnemies[i] > 0) compsWithEnemies++;
          }

          const fillFlags = new Array(compCount).fill(false);

          if (compsWithEnemies === 0) {
            // ì ì´ ë°”ë‹¤ì— í•˜ë‚˜ë„ ì—†ëŠ” ê²½ìš° â†’ ê¸°ì¡´ì²˜ëŸ¼ ê°€ì¥ í° ë°”ë‹¤ë§Œ ë‚¨ê¸°ê³  ë‚˜ë¨¸ì§€ëŠ” ë•…ìœ¼ë¡œ
            let seaId = 0;
            let maxSize = compSizes[0];
            for (let i = 1; i < compCount; i++) {
              if (compSizes[i] > maxSize) {
                maxSize = compSizes[i];
                seaId = i;
              }
            }
            for (let i = 0; i < compCount; i++) {
              if (i !== seaId) fillFlags[i] = true;
            }
          } else if (compsWithEnemies === 1) {
            // ğŸ”¹ ê³µì´ í•œ ê³³ì— ëª¨ë‘ ëª°ë¦° ê²½ìš°:
            // â†’ ê·¸ ì»´í¬ë„ŒíŠ¸ëŠ” ë°”ë‹¤ë¡œ ìœ ì§€, ë‚˜ë¨¸ì§€(ì  ì—†ëŠ” ìª½)ëŠ” ëª¨ë‘ ë•…ìœ¼ë¡œ
            let enemySeaId = -1;
            for (let i = 0; i < compCount; i++) {
              if (compEnemies[i] > 0) {
                enemySeaId = i;
                break;
              }
            }
            for (let i = 0; i < compCount; i++) {
              if (i !== enemySeaId) fillFlags[i] = true;
            }
          } else {
            // ğŸ”¹ ê³µì´ ì—¬ëŸ¬ ì»´í¬ë„ŒíŠ¸ë¡œ ë‚˜ë‰œ ê²½ìš°:
            // 1) ì ì´ ë“¤ì–´ ìˆëŠ” ì»´í¬ë„ŒíŠ¸ ì¤‘ ê°€ì¥ ì‘ì€ ì˜ì—­ í•˜ë‚˜ë¥¼ ì„ íƒí•´ì„œ ì±„ì›€
            // 2) ì ì´ ì „í˜€ ì—†ëŠ” ì»´í¬ë„ŒíŠ¸ëŠ” ì „ë¶€ ì±„ì›€
            let fillEnemyCompId = -1;
            let minSize = Infinity;
            for (let i = 0; i < compCount; i++) {
              if (compEnemies[i] > 0 && compSizes[i] < minSize) {
                minSize = compSizes[i];
                fillEnemyCompId = i;
              }
            }

            // ì ì´ ì—†ëŠ” ë°”ë‹¤ ì˜ì—­ì€ í•­ìƒ ë•…ìœ¼ë¡œ
            for (let i = 0; i < compCount; i++) {
              if (compEnemies[i] === 0) {
                fillFlags[i] = true;
              }
            }
            // ì ì´ ìˆëŠ” ì˜ì—­ ì¤‘ ê°€ì¥ ì‘ì€ ê²ƒ í•˜ë‚˜ë„ ë•…ìœ¼ë¡œ
            if (fillEnemyCompId !== -1) {
              fillFlags[fillEnemyCompId] = true;
            }
          }

          // 4) fillFlagsê°€ trueì¸ ì»´í¬ë„ŒíŠ¸ë§Œ ì‹¤ì œë¡œ ë•…(1)ìœ¼ë¡œ ì±„ì›€
          for (let y = 0; y < CONFIG.ROWS; y++) {
            for (let x = 0; x < CONFIG.COLS; x++) {
              if (board[y][x] === 0) {
                const cid = compIndex[y][x];
                if (cid !== -1 && fillFlags[cid]) {
                  board[y][x] = 1;
                  newlyClaimed++;
                }
              }
            }
          }

          // 5) ì±„ì›Œì§„ ì˜ì—­ ì•ˆì— ìˆë˜ ì  ì œê±° + ì ìˆ˜
          const survivors = [];
          for (let ei = 0; ei < enemies.length; ei++) {
            const cid = enemyCompIds[ei];
            if (cid !== -1 && fillFlags[cid]) {
              // ì±„ìš´ ì˜ì—­ ì•ˆì— ê°‡íŒ ì  â†’ ì†Œë©¸ & ë³´ë„ˆìŠ¤ ì ìˆ˜
              score += 100;
            } else {
              survivors.push(enemies[ei]);
            }
          }
          enemies = survivors;
        }

        // 6) ì•„ì´í…œ ì²˜ë¦¬ (ì±„ì›Œì§„ ë•… ìœ„ì— ìˆëŠ” ì•„ì´í…œ ë°œë™)
        if (items.length > 0) {
          const remains = [];
          for (const it of items) {
            if (board[it.y][it.x] === 1) {
              applyItem(it.type);
            } else {
              remains.push(it);
            }
          }
          items = remains;
        }

        if (newlyClaimed > 0) {
          score += newlyClaimed * 10;
        }

        const fillPercent = getFillPercent();
        updateHUD(fillPercent);

        const commonMsg = "ì´ë¯¸ ì‚¬ìš©ëœ ê¸°í”„í‹°ì½˜ì…ë‹ˆë‹¤ ^^";

        if (fillPercent >= CONFIG.TARGET_PERCENT) {
          running = false;
          restartBtn.style.display = "inline-block";

          if (stage === 1 || stage === 2) {
            const info = STAGE_INFO[stage];
            showOverlay(
              `ìŠ¤í…Œì´ì§€ ${stage} í´ë¦¬ì–´!`,
              commonMsg + "\n" + (info.clearSuffix || ""),
              stage === 1 ? "stage2" : "stage3"
            );
          } else {
            saveScoreIfNeeded();
            showOverlay(
              "ìŠ¤í…Œì´ì§€ 3 í´ë¦¬ì–´!",
              "ë§ˆì§€ë§‰ ë³´ìƒ: ì œì‘ìê°€ ë°¥ ì‚¬ì¤ë‹ˆë‹¤.\n(ì´ê±´ ì§„ì§œì•¼, ì¥ë‚œ ì•„ë‹˜)",
              "restart"
            );
          }
        }
      }

      // ===== ì¿ í° ë°°ê²½ =====
      function drawCouponBackground() {
        const w = canvas.width;
        const h = canvas.height;
        if (!couponCanvas || couponCanvas.width !== w || couponCanvas.height !== h || lastCouponStage !== stage) {
          couponCanvas = document.createElement("canvas");
          couponCanvas.width = w;
          couponCanvas.height = h;
          couponCtx = couponCanvas.getContext("2d");
          lastCouponStage = stage;

          const c = couponCtx;
          c.clearRect(0, 0, w, h);
          c.fillStyle = "#020617";
          c.fillRect(0, 0, w, h);

          const margin = w * 0.08;
          const rx = margin;
          const ry = margin;
          const rw = w - margin * 2;
          const rh = h - margin * 2;

          function roundRectPath(ctx, x, y, w2, h2, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w2 - r, y);
            ctx.quadraticCurveTo(x + w2, y, x + w2, y + r);
            ctx.lineTo(x + w2, y + h2 - r);
            ctx.quadraticCurveTo(x + w2, y + h2, x + w2 - r, y + h2);
            ctx.lineTo(x + r, y + h2);
            ctx.quadraticCurveTo(x, y + h2, x, y + h2 - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
          }

          // ì¿ í° ì¹´ë“œ
          roundRectPath(c, rx, ry, rw, rh, 24);
          c.fillStyle = "#f9fafb";
          c.fill();
          c.lineWidth = 2;
          c.strokeStyle = "#e5e7eb";
          c.stroke();

          // ìƒë‹¨ ë°”
          c.fillStyle = "#111827";
          c.fillRect(rx, ry, rw, rh * 0.16);

          const info = STAGE_INFO[stage] || STAGE_INFO[1];
          c.fillStyle = "#f9fafb";
          c.font = "bold 20px system-ui, sans-serif";
          c.textBaseline = "middle";
          c.fillText(info.couponTitle, rx + 20, ry + rh * 0.08);

          c.fillStyle = "#111827";
          c.font = "16px system-ui, sans-serif";
          c.fillText(info.couponDesc, rx + 20, ry + rh * 0.4);

          // ë°”ì½”ë“œ ëŠë‚Œë§Œ ì‚´ì§
          const bcH = rh * 0.22;
          const bcY = ry + rh - bcH - 24;
          const bcX = rx + 24;
          const bcW = rw - 48;

          roundRectPath(c, bcX, bcY, bcW, bcH, 12);
          c.fillStyle = "#e5e7eb";
          c.fill();
          c.strokeStyle = "#d1d5db";
          c.stroke();

          const cols = 24;
          const colW = bcW / cols;
          for (let i = 0; i < cols; i++) {
            const hRatio = 0.4 + Math.random() * 0.5;
            const x = bcX + i * colW;
            const y = bcY + bcH * (1 - hRatio) * 0.8;
            const h2 = bcH * hRatio;
            c.fillStyle = Math.random() < 0.5 ? "#9ca3af" : "#6b7280";
            c.fillRect(x + colW * 0.2, y, colW * 0.6, h2);
          }

          // ì‚¬ìš©ì™„ë£Œ ìŠ¤íƒ¬í”„
          c.save();
          c.translate(rx + rw * 0.7, ry + rh * 0.35);
          c.rotate(-Math.PI / 7);
          roundRectPath(c, -90, -26, 180, 52, 10);
          c.fillStyle = "rgba(248,113,113,0.18)";
          c.fill();
          c.strokeStyle = "#b91c1c";
          c.lineWidth = 3;
          c.stroke();
          c.fillStyle = "#b91c1c";
          c.font = "bold 20px system-ui, sans-serif";
          c.textAlign = "center";
          c.textBaseline = "middle";
          c.fillText("ì‚¬ìš©ì™„ë£Œ", 0, 0);
          c.restore();
        }

        ctx.drawImage(couponCanvas, 0, 0);
      }

      // ===== ë Œë”ë§ =====
      function drawBoard() {
        for (let y = 0; y < CONFIG.ROWS; y++) {
          for (let x = 0; x < CONFIG.COLS; x++) {
            const v = board[y][x];
            if (v === 0) ctx.fillStyle = "#ffffff";
            else if (v === 1) ctx.fillStyle = "rgba(16,185,129,0.18)";
            else if (v === 2) ctx.fillStyle = "#facc15";
            else continue;
            ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
          }
        }

        // ê²©ì
        ctx.strokeStyle = "rgba(31,41,55,0.7)";
        ctx.lineWidth = 0.5;
        for (let y = 0; y <= CONFIG.ROWS; y++) {
          const py = y * cellSize + 0.5;
          ctx.beginPath();
          ctx.moveTo(0, py);
          ctx.lineTo(canvas.width, py);
          ctx.stroke();
        }
        for (let x = 0; x <= CONFIG.COLS; x++) {
          const px = x * cellSize + 0.5;
          ctx.beginPath();
          ctx.moveTo(px, 0);
          ctx.lineTo(px, canvas.height);
          ctx.stroke();
        }
      }

      function drawItems() {
        const rItem = cellSize * 0.7;
        for (const it of items) {
          const cx = it.x * cellSize + cellSize / 2;
          const cy = it.y * cellSize + cellSize / 2;
          const drawFn = ITEM_DRAWERS[it.type];
          if (drawFn) drawFn(cx, cy, rItem);
        }
      }

      function drawEnemies() {
        for (const enemy of enemies) {
          const r = enemy.radius;
          if (enemy.type === 2) {
            const sides = 11;
            const step = (Math.PI * 2) / sides;
            const startAngle = -Math.PI / 2;
            ctx.beginPath();
            for (let i = 0; i < sides; i++) {
              const ang = startAngle + step * i;
              const ex = enemy.x + Math.cos(ang) * r;
              const ey = enemy.y + Math.sin(ang) * r;
              if (i === 0) ctx.moveTo(ex, ey);
              else ctx.lineTo(ex, ey);
            }
            ctx.closePath();
            ctx.fillStyle = "#fb7185";
            ctx.fill();
            ctx.lineWidth = 3;
            ctx.strokeStyle = "#fecaca";
            ctx.stroke();
          } else {
            ctx.beginPath();
            ctx.arc(enemy.x, enemy.y, r, 0, Math.PI * 2);
            ctx.fillStyle = "#ef4444";
            ctx.fill();
            ctx.lineWidth = 3;
            ctx.strokeStyle = "#fee2e2";
            ctx.stroke();
          }
        }
      }

      function drawPlayer() {
        const px = player.x * cellSize + cellSize / 2;
        const py = player.y * cellSize + cellSize / 2;
        const pr = cellSize * 0.35;
        ctx.beginPath();
        ctx.arc(px, py, pr, 0, Math.PI * 2);
        ctx.fillStyle = "#e5e7eb";
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = "#38bdf8";
        ctx.stroke();
      }

      function draw() {
        drawCouponBackground();
        drawBoard();
        drawItems();
        drawEnemies();
        drawPlayer();
      }

      // ===== ë©”ì¸ ì—…ë°ì´íŠ¸ / ë£¨í”„ =====
      function update(dt) {
        if (!running) return;

        if (speedBuffRemaining > 0) {
          speedBuffRemaining = Math.max(0, speedBuffRemaining - dt);
        }
        const speedFactor = speedBuffRemaining > 0 ? CONFIG.SPEED_BUFF_FACTOR : 1.0;

        const dirNow = getInputDir();
        const hasInput = dirNow.x !== 0 || dirNow.y !== 0;
        if (hasInput && !lastHasInput) {
          moveTimer += CONFIG.MOVE_INTERVAL;
        }
        lastHasInput = hasInput;

        moveTimer += dt * speedFactor;
        const steps = Math.floor(moveTimer / CONFIG.MOVE_INTERVAL);
        if (steps <= 0) return;
        moveTimer -= steps * CONFIG.MOVE_INTERVAL;

        for (let i = 0; i < steps; i++) {
          stepPlayer();
          stepEnemies();
          checkCollisions();
        }
      }

      function loop(timestamp) {
        if (!lastTime) lastTime = timestamp;
        const dt = timestamp - lastTime;
        lastTime = timestamp;
        update(dt);
        draw();
        requestAnimationFrame(loop);
      }

      // ===== ìŠ¤í…Œì´ì§€ ì…‹ì—… =====
      function setupStage(stageNum, resetScoreAndLives) {
        if (resetScoreAndLives) {
          score = 0;
          lives = CONFIG.MAX_LIVES;
          speedBuffRemaining = 0;
        }
        board = createEmptyBoard();
        resetPlayer();
        spawnEnemiesForStage(stageNum);
        spawnItemsForStage(stageNum);
        updateHUD(getFillPercent());
      }

      // ì´ˆê¸° ì‹¤í–‰
      bindJoystick();
      startNewGame();
      requestAnimationFrame(loop);
    })();
  </script>
</body>
</html>
