<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>고누</title>
<style>
  :root{
    --bg:#070a16; --panel:#11152b; --ink:#e9edff; --muted:#9aa3c7; --accent:#7aa2ff;
    --panel2:#0b0f1e;
  }
  *{box-sizing:border-box}
  html,body{
    margin:0;
    background:var(--bg);
    color:var(--ink);
    font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto;
  }
  .wrap{max-width:980px;margin:0 auto;padding:16px}
  header{display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap}
  h1{font-size:22px;margin:0}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .btn{
    padding:7px 11px;
    border:1px solid #2a315e;
    border-radius:12px;
    background:#1b2145;
    color:var(--ink);
    cursor:pointer;
    font-size:14px;
  }
  .btn-primary{
    background:linear-gradient(180deg,#2e4cff,#2337a7);
    border-color:#3a50ff;
  }
  .btn:disabled{opacity:.5;cursor:not-allowed}
  .tag{
    display:inline-flex;gap:8px;align-items:center;
    padding:6px 10px;border:1px solid #2b325c;
    border-radius:999px;background:#121632;color:var(--muted);
  }
  .panel{
    background:var(--panel2);
    border:1px solid #222747;
    border-radius:16px;
    padding:12px;
  }
  canvas{
    width:100%;height:auto;max-width:640px;
    display:block;margin:0 auto;
    border-radius:12px;
    background:radial-gradient(900px 450px at 50% -200px,#151a3e 10%,#050712 60%,#020309 100%);
  }
  label{font-size:14px;color:var(--muted)}
  select{
    padding:5px 8px;
    border-radius:10px;
    border:1px solid #2b325c;
    background:#10142c;
    color:var(--ink);
    font-size:14px;
  }
  .info{font-size:14px;color:#9aa3c7;margin-top:6px}
  .pill{
    padding:4px 10px;border-radius:999px;
    border:1px solid #374151;
    background:#030711;font-size:13px;color:#cbd5f5;
  }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1 id="title-main">우물고누 / 호박고누</h1>
    <div class="row">
      <button id="btn-new" class="btn btn-primary">새 게임</button>
      <button id="btn-undo" class="btn">되돌리기</button>
    </div>
  </header>

  <div class="row" style="margin-top:10px;margin-bottom:8px">
    <span class="tag">현재 판 <b id="board-label">우물고누 (말 2개)</b></span>
    <span class="tag">턴 <b id="turn-label">흑(아래)</b></span>
    <span class="tag">상태 <b id="status-label">게임 준비</b></span>
  </div>

  <div class="row" style="margin-bottom:8px">
    <label>판 선택&nbsp;
      <select id="sel-mode">
        <option value="woomul">우물고누 (말 2개)</option>
        <option value="hobak">호박고누 (말 3개)</option>
      </select>
    </label>
    <label>대전 방식&nbsp;
      <select id="sel-ai">
        <option value="none">사람 vs 사람</option>
        <option value="easy">AI 초보 (느긋)</option>
        <option value="normal">AI 중수</option>
        <option value="hard">AI 고수</option>
      </select>
    </label>
    <span class="pill">파란 복주머니: 아래쪽 / 빨간 복주머니: 위쪽</span>
  </div>

  <div class="panel">
    <canvas id="board" width="640" height="640" aria-label="우물고누 / 호박고누 보드"></canvas>
    <div class="info">
      말을 클릭하여 선택한 뒤, 선으로 연결된 지점을 클릭하면 이동합니다.<br>
      상대 말을 움직일 수 없게 막으면 승리합니다. 되돌리기로 바로 전 수를 취소할 수 있어요.
    </div>
  </div>
</div>

<script>
(function(){
  'use strict';

  const CV = document.getElementById('board');
  const CTX = CV.getContext('2d');

  const boardLabel = document.getElementById('board-label');
  const turnLabel  = document.getElementById('turn-label');
  const statusLabel= document.getElementById('status-label');
  const selMode    = document.getElementById('sel-mode');
  const selAI      = document.getElementById('sel-ai');
  const btnNew     = document.getElementById('btn-new');
  const btnUndo    = document.getElementById('btn-undo');

  const CENTER = {x:320,y:320};

  function polar(angleRad, radius){
    return {
      x: CENTER.x + Math.cos(angleRad)*radius,
      y: CENTER.y + Math.sin(angleRad)*radius
    };
  }

  const BOARD_DEFS = {
    woomul:{
      name:'우물고누',
      piecesPerSide:2,
      nodes:(()=>{
        const r = 170;
        const top    = polar(-Math.PI/2,r);
        const right  = polar(0,r);
        const center = {x:CENTER.x,y:CENTER.y};
        const bottom = polar(Math.PI/2,r);
        const left   = polar(Math.PI,r);
        return [top,right,center,bottom,left];
      })(),
      neighbors:[
        [2,4,1],
        [0,2],
        [0,1,3,4],
        [2,4],
        [0,2,3]
      ]
    },
    hobak:{
      name:'호박고누',
      piecesPerSide:3,
      nodes:(()=>{
        const nodes = [];
        const r = 170;
        const topY = CENTER.y - r - 60;
        const botY = CENTER.y + r + 60;
        const campX = 140;
        nodes.push({x:CENTER.x-campX,y:topY}); //0
        nodes.push({x:CENTER.x,y:topY});       //1
        nodes.push({x:CENTER.x+campX,y:topY}); //2
        nodes.push(polar(-Math.PI/2,r));       //3
        nodes.push(polar(0,r));                //4
        nodes.push(polar(Math.PI/2,r));        //5
        nodes.push(polar(Math.PI,r));          //6
        nodes.push({x:CENTER.x-campX,y:botY}); //7
        nodes.push({x:CENTER.x,y:botY});       //8
        nodes.push({x:CENTER.x+campX,y:botY}); //9
        nodes.push({x:CENTER.x,y:CENTER.y});   //10
        return nodes;
      })(),
      neighbors:[
        [1],
        [0,2,3],
        [1],
        [1,10,4,6],
        [3,5,10],
        [4,6,10,8],
        [5,3,10],
        [8],
        [7,9,5],
        [8],
        [3,4,5,6]
      ],
      campTop:[0,1,2],
      campBottom:[7,8,9]
    }
  };

  const S = {
    boardType:'woomul',
    aiLevel:'none',
    turn:0,
    pieces:[[],[]],
    selected:null,
    history:[],
    gameOver:false,
    winner:null,
    moveCount:0
  };

  function clonePieces(pieces){
    return pieces.map(arr=>arr.map(p=>({node:p.node,leftCamp:p.leftCamp||false})));
  }

  function snapshot(){
    return {
      boardType:S.boardType,
      aiLevel:S.aiLevel,
      turn:S.turn,
      pieces:clonePieces(S.pieces),
      gameOver:S.gameOver,
      winner:S.winner,
      moveCount:S.moveCount
    };
  }

  function loadSnapshot(snap){
    S.boardType = snap.boardType;
    S.aiLevel   = snap.aiLevel;
    S.turn      = snap.turn;
    S.pieces    = clonePieces(snap.pieces);
    S.selected  = null;
    S.gameOver  = snap.gameOver;
    S.winner    = snap.winner;
    S.moveCount = snap.moveCount;
    updateTexts();
    draw();
  }

  function isCamp(node){
    const def=BOARD_DEFS.hobak;
    return def.campTop.includes(node) || def.campBottom.includes(node);
  }

  function newGame(){
    S.boardType = selMode.value;
    S.aiLevel   = selAI.value;
    S.turn = 0;
    S.selected=null;
    S.gameOver=false;
    S.winner=null;
    S.history=[];
    S.moveCount=0;

    S.pieces = [[],[]];

    if(S.boardType==='woomul'){
      S.pieces[0].push({node:3});
      S.pieces[0].push({node:1});
      S.pieces[1].push({node:0});
      S.pieces[1].push({node:4});
    }else{
      S.pieces[0].push({node:7,leftCamp:false});
      S.pieces[0].push({node:8,leftCamp:false});
      S.pieces[0].push({node:9,leftCamp:false});

      S.pieces[1].push({node:0,leftCamp:false});
      S.pieces[1].push({node:1,leftCamp:false});
      S.pieces[1].push({node:2,leftCamp:false});
    }

    updateTexts();
    draw();
  }

  function nodeAtPos(x,y){
    const def = BOARD_DEFS[S.boardType];
    let best=-1, bestD=Infinity;
    for(let i=0;i<def.nodes.length;i++){
      const n=def.nodes[i];
      const dx=x-n.x, dy=y-n.y;
      const d=dx*dx+dy*dy;
      if(d<bestD){
        bestD=d;best=i;
      }
    }
    if(Math.sqrt(bestD)<=24) return best;
    return -1;
  }
  function pieceAtNode(player,node){
    const arr=S.pieces[player];
    for(let i=0;i<arr.length;i++){
      if(arr[i].node===node) return i;
    }
    return -1;
  }
  function pieceAtNodeState(state,player,node){
    const arr=state.pieces[player];
    for(let i=0;i<arr.length;i++){
      if(arr[i].node===node) return i;
    }
    return -1;
  }

  function canMovePiece(state,player,pIndex,toNode){
    const def = BOARD_DEFS[state.boardType];
    const piece = state.pieces[player][pIndex];
    const from = piece.node;

    if(from===toNode) return false;
    if(def.neighbors[from].indexOf(toNode)===-1) return false;

    if(pieceAtNodeState(state,0,toNode)!==-1) return false;
    if(pieceAtNodeState(state,1,toNode)!==-1) return false;

    if(state.boardType==='hobak'){
      const toInCamp = isCamp(toNode);
      const leftCamp = !!piece.leftCamp;

      if(leftCamp && toInCamp) return false;
    }
    return true;
  }

  function generateMoves(state, player){
    if(state.gameOver) return [];
    const def = BOARD_DEFS[state.boardType];
    const moves=[];
    const arr = state.pieces[player];

    for(let i=0;i<arr.length;i++){
      const from = arr[i].node;
      for(const to of def.neighbors[from]){
        if(canMovePiece(state,player,i,to)){
          moves.push({piece:i,from,to});
        }
      }
    }
    return moves;
  }

  function applyMoveInPlace(state, player, move){
    const piece = state.pieces[player][move.piece];
    const from = piece.node;
    const to   = move.to;

    if(state.boardType==='hobak'){
      if(!piece.leftCamp){
        const fromInCamp = isCamp(from);
        const toInCamp   = isCamp(to);
        if(fromInCamp && !toInCamp){
          piece.leftCamp = true;
        }
      }
    }
    piece.node = to;

    state.turn = 1-player;
    state.moveCount++;

    const nextMoves = generateMoves(state, state.turn);
    if(nextMoves.length===0){
      state.gameOver = true;
      state.winner = player;
    }
  }

  function evaluateState(state, player){
    if(state.gameOver){
      if(state.winner===player) return 100;
      if(state.winner===1-player) return -100;
      return 0;
    }
    const my  = generateMoves(state, player).length;
    const opp = generateMoves(state, 1-player).length;
    return my - opp;
  }

  function minimax(state, depth, player, maximizing){
    if(depth===0 || state.gameOver){
      return {score:evaluateState(state,player)};
    }
    const cur = maximizing ? player : 1-player;
    const moves = generateMoves(state, cur);
    if(moves.length===0){
      const score = cur===player ? -100 : 100;
      return {score};
    }
    let bestMove=null;
    if(maximizing){
      let best=-Infinity;
      for(const mv of moves){
        const ns = {
          boardType:state.boardType,
          aiLevel:state.aiLevel,
          turn:state.turn,
          pieces:clonePieces(state.pieces),
          gameOver:state.gameOver,
          winner:state.winner,
          moveCount:state.moveCount
        };
        applyMoveInPlace(ns, cur, mv);
        const r = minimax(ns, depth-1, player, !maximizing).score;
        if(r>best){
          best=r; bestMove=mv;
        }
      }
      return {score:best, move:bestMove};
    }else{
      let best=Infinity;
      for(const mv of moves){
        const ns = {
          boardType:state.boardType,
          aiLevel:state.aiLevel,
          turn:state.turn,
          pieces:clonePieces(state.pieces),
          gameOver:state.gameOver,
          winner:state.winner,
          moveCount:state.moveCount
        };
        applyMoveInPlace(ns, cur, mv);
        const r = minimax(ns, depth-1, player, !maximizing).score;
        if(r<best){
          best=r; bestMove=mv;
        }
      }
      return {score:best, move:bestMove};
    }
  }

  function aiMove(){
    if(S.gameOver) return;
    if(S.aiLevel==='none') return;
    const player = 1;
    if(S.turn!==player) return;

    const moves = generateMoves(S, player);
    if(moves.length===0) return;

    let chosen;
    if(S.aiLevel==='easy'){
      chosen = moves[Math.floor(Math.random()*moves.length)];
    }else if(S.aiLevel==='normal'){
      let best=-Infinity;
      for(const mv of moves){
        const ns = snapshot();
        applyMoveInPlace(ns, player, mv);
        const oppMoves = generateMoves(ns, 1-player).length;
        const score = -oppMoves + Math.random()*0.1;
        if(score>best){
          best=score; chosen=mv;
        }
      }
    }else{
      const res = minimax(snapshot(), 3, player, true);
      chosen = res.move || moves[Math.floor(Math.random()*moves.length)];
    }

    S.history.push(snapshot());
    applyMoveInPlace(S, player, chosen);
    updateTexts();
    draw();
  }

  function handleClick(ev){
    const rect = CV.getBoundingClientRect();
    const scaleX = CV.width / rect.width;
    const scaleY = CV.height / rect.height;
    const x = (ev.clientX - rect.left) * scaleX;
    const y = (ev.clientY - rect.top) * scaleY;
    const node = nodeAtPos(x,y);
    if(node===-1) return;
    if(S.gameOver) return;

    const player = S.turn;

    if(S.aiLevel!=='none' && player===1){
      return;
    }

    if(!S.selected){
      const idx = pieceAtNode(player,node);
      if(idx!==-1){
        S.selected = {player,index:idx};
        draw();
      }
      return;
    }

    if(S.selected.player===player){
      const idx = pieceAtNode(player,node);
      if(idx!==-1){
        S.selected = {player,index:idx};
        draw();
        return;
      }
    }

    const sel = S.selected;
    if(sel.player!==player) return;
    if(!canMovePiece(S, player, sel.index, node)) return;

    S.history.push(snapshot());
    applyMoveInPlace(S, player, {piece:sel.index,from:S.pieces[player][sel.index].node,to:node});
    S.selected=null;
    updateTexts();
    draw();

    if(S.gameOver) return;

    if(S.turn===1 && S.aiLevel!=='none'){
      setTimeout(aiMove, 200);
    }
  }

  CV.addEventListener('click', handleClick);

  btnUndo.addEventListener('click', ()=>{
    if(!S.history.length) return;
    const snap = S.history.pop();
    loadSnapshot(snap);
  });

  btnNew.addEventListener('click', newGame);
  selMode.addEventListener('change', newGame);
  selAI.addEventListener('change', ()=>{
    S.aiLevel = selAI.value;
    updateTexts();
  });

  function drawBoardWoomul(def){
    CTX.save();
    CTX.strokeStyle='#f9fafb';
    CTX.lineWidth=6;
    CTX.lineCap='round';

    const r=170;
    const {x:cx,y:cy}=CENTER;

    CTX.beginPath();
    CTX.arc(cx,cy,r,Math.PI*0.5,Math.PI*1.5,false);
    CTX.stroke();

    CTX.beginPath();
    CTX.arc(cx,cy,r,-Math.PI*0.5,0,false);
    CTX.stroke();

    CTX.beginPath();
    CTX.moveTo(cx,cy-r);
    CTX.lineTo(cx,cy+r);
    CTX.moveTo(cx-r,cy);
    CTX.lineTo(cx+r,cy);
    CTX.stroke();

    CTX.restore();
  }

  function drawBoardHobak(def){
    CTX.save();
    CTX.strokeStyle='#f9fafb';
    CTX.lineWidth=6;
    CTX.lineCap='round';

    const r=170;
    const {x:cx,y:cy}=CENTER;
    const topY = def.nodes[0].y;
    const botY = def.nodes[7].y;
    const leftX = def.nodes[0].x;
    const rightX= def.nodes[2].x;

    CTX.beginPath();
    CTX.moveTo(leftX, topY);
    CTX.lineTo(rightX, topY);
    CTX.moveTo(leftX, botY);
    CTX.lineTo(rightX, botY);
    CTX.stroke();

    CTX.beginPath();
    CTX.moveTo(cx, topY);
    CTX.lineTo(cx, botY);
    CTX.stroke();

    CTX.beginPath();
    CTX.arc(cx,cy,r,0,Math.PI*2);
    CTX.stroke();

    CTX.beginPath();
    CTX.moveTo(cx-r,cy);
    CTX.lineTo(cx+r,cy);
    CTX.moveTo(cx,cy-r);
    CTX.lineTo(cx,cy+r);
    CTX.stroke();

    CTX.restore();
  }

  function drawNodes(def){
    CTX.save();
    for(let i=0;i<def.nodes.length;i++){
      const n=def.nodes[i];
      CTX.beginPath();
      CTX.arc(n.x,n.y,4,0,Math.PI*2);
      CTX.fillStyle='rgba(209,213,219,0.6)';
      CTX.fill();
    }
    CTX.restore();
  }

  // ==== 복주머니 말 그리기 (이미지 느낌 버전) ====
  function drawPieces(def){
    function drawPouch(nodeIdx,player,highlight){
      const n = def.nodes[nodeIdx];
      CTX.save();
      CTX.translate(n.x, n.y);

      if(highlight){
        CTX.shadowColor = '#fde047';
        CTX.shadowBlur  = 20;
      }else{
        CTX.shadowBlur = 0;
      }

      const isBlue = (player===0);   // 아래쪽: 파란 복주머니
      const r = 22;

      // 바닥 그림자
      CTX.save();
      CTX.globalAlpha = 0.35;
      CTX.fillStyle = 'black';
      CTX.beginPath();
      CTX.ellipse(0, r*1.05, r*0.95, r*0.35, 0, 0, Math.PI*2);
      CTX.fill();
      CTX.restore();

      // 메인 몸통 색 그라디언트
      const bagGrad = CTX.createLinearGradient(0,-r,0,r);
      if(isBlue){
        bagGrad.addColorStop(0, '#dbeafe');
        bagGrad.addColorStop(0.4, '#60a5fa');
        bagGrad.addColorStop(1, '#1d4ed8');
      }else{
        bagGrad.addColorStop(0, '#fee2e2');
        bagGrad.addColorStop(0.4, '#fb7185');
        bagGrad.addColorStop(1, '#e11d48');
      }
      CTX.fillStyle = bagGrad;

      // 통통한 복주머니 몸통
      CTX.beginPath();
      CTX.moveTo(0, -r*0.85);
      CTX.bezierCurveTo( r*0.85, -r*0.7,  r*1.0, -r*0.1,  r*0.9,  r*0.6);
      CTX.bezierCurveTo( r*0.5,  r*1.1,  r*0.1,  r*1.2,  0,      r*1.2);
      CTX.bezierCurveTo(-r*0.1,  r*1.2, -r*0.5,  r*1.1, -r*0.9,  r*0.6);
      CTX.bezierCurveTo(-r*1.0, -r*0.1, -r*0.85, -r*0.7, 0, -r*0.85);
      CTX.closePath();
      CTX.fill();

      CTX.lineWidth = 2;
      CTX.strokeStyle = isBlue ? '#1e3a8a' : '#7f1d1d';
      CTX.stroke();

      // 아래쪽 색동(둥근 띠)
      const stripeColorsBlue  = ['#60a5fa','#38bdf8','#22c55e','#eab308','#f97316','#a855f7'];
      const stripeColorsRed   = ['#f97373','#f97316','#facc15','#4ade80','#38bdf8','#a855f7'];
      const stripes = isBlue ? stripeColorsBlue : stripeColorsRed;
      const startAngle = Math.PI*0.15;
      const endAngle   = Math.PI*0.85;
      const angleSpan  = (endAngle - startAngle) / stripes.length;

      const innerR = r*0.85;
      const outerR = r*1.05;
      for(let i=0;i<stripes.length;i++){
        const a0 = startAngle + i*angleSpan;
        const a1 = a0 + angleSpan;
        CTX.beginPath();
        CTX.arc(0,0,outerR,a0,a1);
        CTX.arc(0,0,innerR,a1,a0,true);
        CTX.closePath();
        CTX.fillStyle = stripes[i];
        CTX.fill();
      }

      // 중앙 금색 원(테두리)
      const ringOuter = r*0.78;
      const ringInner = r*0.55;
      CTX.beginPath();
      CTX.arc(0,0,ringOuter,0,Math.PI*2);
      CTX.fillStyle = '#facc15';
      CTX.fill();

      CTX.beginPath();
      CTX.arc(0,0,ringInner,0,Math.PI*2);
      CTX.fillStyle = 'white';
      CTX.fill();

      // 안쪽에 간단한 장식(작은 반원들)
      CTX.save();
      CTX.strokeStyle = '#fbbf24';
      CTX.lineWidth = 1.4;
      for(let i=0;i<6;i++){
        const a = (Math.PI*2/6)*i;
        const cx = Math.cos(a)*((ringOuter+ringInner)/2);
        const cy = Math.sin(a)*((ringOuter+ringInner)/2);
        CTX.beginPath();
        CTX.arc(cx,cy,ringOuter*0.08,0,Math.PI*2);
        CTX.stroke();
      }
      CTX.restore();

      // 중앙 "복" 글자
      CTX.fillStyle = '#f59e0b';
      CTX.font = 'bold 14px system-ui';
      CTX.textAlign = 'center';
      CTX.textBaseline = 'middle';
      CTX.fillText('복', 0, 1);

      // 윗부분 하트형 뚜껑
      const topH = r*0.9;
      CTX.beginPath();
      CTX.moveTo(0, -topH);
      CTX.bezierCurveTo(-r*0.4, -topH*1.15, -r*0.45, -topH*0.7, -r*0.25, -topH*0.55);
      CTX.bezierCurveTo(0, -topH*0.25, r*0.25, -topH*0.55, r*0.25, -topH*0.55);
      CTX.bezierCurveTo(r*0.45, -topH*0.7, r*0.4, -topH*1.15, 0, -topH);
      CTX.closePath();
      CTX.fillStyle = isBlue ? '#1d4ed8' : '#e11d48';
      CTX.fill();

      // 목 부분 노란 띠
      CTX.beginPath();
      CTX.ellipse(0,-r*0.55,r*0.8,r*0.22,0,0,Math.PI,true);
      CTX.fillStyle = '#facc15';
      CTX.fill();

      // 끈
      CTX.lineWidth = 2;
      CTX.strokeStyle = '#facc15';
      CTX.beginPath();
      CTX.moveTo(-r*0.25,-r*0.55);
      CTX.bezierCurveTo(-r*0.6,-r*0.4,-r*0.7,-r*0.1,-r*0.6,r*0.1);
      CTX.stroke();
      CTX.beginPath();
      CTX.moveTo( r*0.25,-r*0.55);
      CTX.bezierCurveTo( r*0.6,-r*0.4, r*0.7,-r*0.1, r*0.6,r*0.1);
      CTX.stroke();

      // 끈 끝 장식
      CTX.beginPath();
      CTX.arc(-r*0.6,r*0.12,2.5,0,Math.PI*2);
      CTX.arc( r*0.6,r*0.12,2.5,0,Math.PI*2);
      CTX.fillStyle = isBlue ? '#bfdbfe' : '#fed7aa';
      CTX.fill();

      // 몸통 하이라이트
      CTX.save();
      CTX.globalAlpha = 0.3;
      CTX.fillStyle = 'white';
      CTX.beginPath();
      CTX.moveTo(-r*0.2,-r*0.1);
      CTX.bezierCurveTo(0,-r*0.35,r*0.35,-r*0.05,r*0.15,r*0.25);
      CTX.bezierCurveTo(-r*0.05,r*0.25,-r*0.18,r*0.1,-r*0.2,-r*0.1);
      CTX.closePath();
      CTX.fill();
      CTX.restore();

      CTX.restore();
    }

    for(let p=0;p<2;p++){
      const arr=S.pieces[p];
      for(let i=0;i<arr.length;i++){
        const isSel = S.selected && S.selected.player===p && S.selected.index===i;
        drawPouch(arr[i].node,p,isSel);
      }
    }
  }

  function draw(){
    CTX.clearRect(0,0,CV.width,CV.height);

    CTX.fillStyle='#020617';
    CTX.fillRect(0,0,CV.width,CV.height);

    const def = BOARD_DEFS[S.boardType];

    const g = CTX.createRadialGradient(CENTER.x,CENTER.y,0,CENTER.x,CENTER.y,260);
    g.addColorStop(0,'rgba(37,99,235,0.35)');
    g.addColorStop(0.6,'rgba(15,23,42,0.9)');
    g.addColorStop(1,'rgba(2,6,23,1)');
    CTX.fillStyle=g;
    CTX.fillRect(0,0,CV.width,CV.height);

    if(S.boardType==='woomul') drawBoardWoomul(def);
    else drawBoardHobak(def);

    drawNodes(def);
    drawPieces(def);

    if(S.gameOver){
      CTX.save();
      CTX.fillStyle='rgba(0,0,0,0.55)';
      CTX.fillRect(0,0,CV.width,CV.height);
      CTX.fillStyle='#e5e7eb';
      CTX.font='bold 32px system-ui';
      const msg = (S.winner===0?'파란 복주머니 승리!':'빨간 복주머니 승리!');
      const w = CTX.measureText(msg).width;
      CTX.fillText(msg, (CV.width-w)/2, CENTER.y);
      CTX.restore();
    }
  }

  function updateTexts(){
    boardLabel.textContent = S.boardType==='woomul'
      ? '우물고누 (말 2개)'
      : '호박고누 (말 3개)';

    turnLabel.textContent = S.turn===0 ? '흑(아래)' : '백(위)';

    if(S.gameOver){
      statusLabel.textContent = (S.winner===0?'파란 복주머니 승리!':'빨간 복주머니 승리!');
    }else{
      const ai = S.aiLevel;
      let modeText;
      if(ai==='none') modeText='사람 vs 사람';
      else if(ai==='easy') modeText='사람 vs AI 초보';
      else if(ai==='normal') modeText='사람 vs AI 중수';
      else modeText='사람 vs AI 고수';
      statusLabel.textContent = modeText;
    }
  }

  newGame();
})();
</script>
</body>
</html>
